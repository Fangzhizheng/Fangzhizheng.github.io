
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>js面试题 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="1.同源策略同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。
同源策略,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 5.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://example.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">js面试题</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">js面试题</h1>
        <div class="stuff">
            <span>六月 10, 2020</span>
            

        </div>
        <div class="content markdown">
            <h4 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h4><p>同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。</p>
<p>同源策略： 协议、主机、端口必须完全一致</p>
<h4 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2.跨域"></a>2.跨域</h4><p>前端开发中：用浏览器向服务器通过ajax发送请求，当协议、主机、端口不一致的时候，会有跨域问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">跨域问题产生的原因 ：浏览器的同源策略导致了跨域。当我们在前端开发中使用ajax&#x2F;fetch这些技术发送网络请求的时候，当协议、主机、端口有任何一个不一致的时候，则构成跨域。</span><br><span class="line">跨域的作用 ：用于隔离潜在恶意文件的重要安全机制</span><br><span class="line">跨域问题的解决：</span><br><span class="line">1. jsonp ，允许 script 加载第三方资源</span><br><span class="line">2. 在服务器使用cors实现跨域资源共享</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;text&#x2F;html; charset&#x3D;UTF-8&quot;,</span><br><span class="line">        &quot;Access-Control-Allow-Origin&quot;:&#39;http:&#x2F;&#x2F;localhost&#39;,</span><br><span class="line">        &#39;Access-Control-Allow-Methods&#39;: &#39;GET, POST, OPTIONS&#39;,</span><br><span class="line">        &#39;Access-Control-Allow-Headers&#39;: &#39;X-Requested-With, Content-Type&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">3. 在前端的工程化项目(webpack)中,我们可以通过配置devserver的proxy来解决跨域访问的问题。他的原理是在本地开启一个服务器向数据服务器发送请求，因为服务器和服务器之间是没有跨域</span><br><span class="line">4. 但是因为webpack的devserver只在开发环境下有效，当项目发布上线之后仍然会有跨域问题，为了解决项目上线的跨域问题，我们配置服务器的反向代理（Apache&#x2F;ngix）来实现跨域请求 </span><br><span class="line">5. 除此之外，我还知道当项目打包成apk之后就不存在跨域问题了，所以如果项目要打包成apk，我们需要在项目中的所有请求中写全路径(此时我们可以配置axios.default.baseURL来解决)</span><br><span class="line">6. iframe 嵌套通讯，postmessage</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 阮一峰</a></p>
<h4 id="3-JSONP"><a href="#3-JSONP" class="headerlink" title="3.JSONP"></a>3.JSONP</h4><p>Jsonp 并不是一种数据格式，jsonp 是用来解决跨域获取数据的一种解决方案。</p>
<p>具体是通过动态创建 script 标签向服务器发送请求，然后服务器返回一段JS脚本给客户端，然后客户端收到JS脚本立马执行对应的代码。为此，服务器应该设置响应头为 application/javascript</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hansexploration/article/details/80314948">https://blog.csdn.net/hansexploration/article/details/80314948</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;JSONP中服务器给客户端返回一段js脚本</span><br><span class="line">res.setContentType(&quot;application&#x2F;javascript&quot;)</span><br><span class="line">res.send(&quot;fun(&#39;这是你要的数据&#39;)&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;客户端接收到服务器返回的js脚本之后，执行该脚本从而获取服务器返回的数据</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   fun(msg)&#123;</span><br><span class="line">       console.log(msg)</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-事件绑定的方式"><a href="#4-事件绑定的方式" class="headerlink" title="4.事件绑定的方式"></a>4.事件绑定的方式</h4><ul>
<li>嵌入dom</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;func()&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接绑定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件监听</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(&#39;click&#39;,function()&#123;&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="5-事件委托"><a href="#5-事件委托" class="headerlink" title="5.事件委托"></a>5.事件委托</h4><p>事件委托利用了事件冒泡，将子元素自己的事件交给父亲来处理。(子元素自己不绑定事件也不处理事件，委托给父元素来处理)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;苹果&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;香蕉&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;凤梨&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; good好  事件委托</span><br><span class="line">document.querySelector(&#39;ul&#39;).onclick &#x3D; (event) &#x3D;&gt; &#123;</span><br><span class="line">  var ev &#x3D; event || window.event;</span><br><span class="line">  var target &#x3D; ev.target || ev.srcElement;&#x2F;&#x2F;IE浏览器</span><br><span class="line">  if (target.nodeName &#x3D;&#x3D;&#x3D; &#39;LI&#39;) &#123;</span><br><span class="line">    console.log(target.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; bad不好  给每一个li绑定事件</span><br><span class="line">document.querySelectorAll(&#39;li&#39;).forEach((e) &#x3D;&gt; &#123;</span><br><span class="line">  e.onclick &#x3D; function() &#123;</span><br><span class="line">    console.log(this.innerHTML)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>


<h4 id="6-事件循环"><a href="#6-事件循环" class="headerlink" title="6.事件循环"></a>6.事件循环</h4><p>事件循环是一个单线程循环，用于将任务队列中的回调函数(任务)调度入栈。如果调用栈中的任务执行完毕并且任务队列中有对应的回调函数(任务)，则将回调函数出队并推送到调用栈中执行。</p>
<p><img src="G:/Workspace/Z-前端面试题/Front-end-knowledge/assets/1576485332149.png" alt="1576485332149"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">宏任务：script    setTimeout   setInterval  setImmediate, I&#x2F;O, UI rendering   </span><br><span class="line">微任务：process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</span><br><span class="line"></span><br><span class="line">事件循环的任务队列有宏任务队列和微任务队列，每次一个宏任务执行完毕的时候，都会把微任务队列中的微任务执行完毕之后才会再次执行下一个宏任务。</span><br></pre></td></tr></table></figure>

<h4 id="7-事件模型"><a href="#7-事件模型" class="headerlink" title="7.事件模型"></a>7.事件模型</h4><ul>
<li><p>DOM0事件  </p>
<p>直接绑定<br>同一个元素的同一种事件只能绑定一个函数，否则后面的函数会覆盖之前的函数 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">绑定方法：</span><br><span class="line">&lt;input onclick&#x3D;&quot;sayHi()&quot;&#x2F;&gt; </span><br><span class="line">或 btn.onclick &#x3D; function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">解除绑定方法：</span><br><span class="line">btn.onclick &#x3D; null</span><br></pre></td></tr></table></figure>

<ul>
<li>DOM2事件<br>DOM2级事件可以冒泡和捕获<br>通过addEventListener绑定，同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行<br>通过removeEventListener解绑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 绑定</span><br><span class="line">btn.addEventListener(&#39;click&#39;, sayHi)</span><br><span class="line">&#x2F;&#x2F; 解绑</span><br><span class="line">btn.removeEventListener(&#39;click&#39;, sayHi)</span><br><span class="line"></span><br><span class="line">dom2 级事件有三个参数： </span><br><span class="line">第一个参数是事件名（如click）；</span><br><span class="line">第二个参数是事件处理程序函数；</span><br><span class="line">第三个参数如果是true则表示在捕获阶段调用，为false表示在冒泡阶段调用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>DOM3事件<br>DOM3具有更多事件类型<br>DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">UI事件，当用户与页面上的元素交互时触发，如：load、scroll</span><br><span class="line">焦点事件，当元素获得或失去焦点时触发，如：blur、focus</span><br><span class="line">鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup</span><br><span class="line">滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</span><br><span class="line">文本事件，当在文档中输入文本时触发，如：textInput</span><br><span class="line">键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</span><br><span class="line">合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart</span><br><span class="line">变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3acdf5f71d5b">https://www.jianshu.com/p/3acdf5f71d5b</a></p>
<h4 id="8-target和currentTarget区别"><a href="#8-target和currentTarget区别" class="headerlink" title="8.target和currentTarget区别"></a>8.target和currentTarget区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">event.target：返回触发事件的元素</span><br><span class="line">event.currentTarget：返回绑定事件的元素</span><br><span class="line"></span><br><span class="line">ul.onclick &#x3D; function(e)&#123;</span><br><span class="line">    e.target   &#x2F;&#x2F;ul  li</span><br><span class="line">    e.currentTarget  &#x2F;&#x2F;ul</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="9-prototype和-proto-的关系是什么"><a href="#9-prototype和-proto-的关系是什么" class="headerlink" title="9.prototype和__proto__的关系是什么"></a>9.prototype和<code>__proto__</code>的关系是什么</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>函数有一个prototype属性，这个属性表示函数的原型</span><br><span class="line">  这个属性中有三部分信息：构造函数   所有实例公共的属性和方法   __proto__</span><br><span class="line"><span class="number">2.</span>对象有一个__proto__属性，他指向函数的原型</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>);</span><br><span class="line">  p.__proto__ == Person.prototype;</span><br><span class="line"><span class="number">3.</span>函数原型中的信息</span><br><span class="line">  Person.prototype.constructor == Person;</span><br><span class="line">  Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype;</span><br><span class="line">  <span class="built_in">Object</span>.prototype.__proto__ == <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//a._proto_是隐式原型，prototype是显示原型</span></span><br><span class="line"><span class="comment">//b.prototype：每一个函数创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象</span></span><br><span class="line"><span class="comment">//c._proto_ ：javascript中任意的对象都有一个内置属性，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过_proto_来访问。</span></span><br></pre></td></tr></table></figure>


<h4 id="10-什么是Ajax-ajax常用属性和方法"><a href="#10-什么是Ajax-ajax常用属性和方法" class="headerlink" title="10.什么是Ajax,ajax常用属性和方法"></a>10.什么是Ajax,ajax常用属性和方法</h4><p>Ajax(asynchronous JavaScript and XML) 是使用js向服务器发送请求的一种异步通信的机制。</p>
<p>Ajax的好处：</p>
<p>1.异步请求，可以不断向服务器发送请求</p>
<p>2.允许我们局部刷新页面  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let xmlhttp</span><br><span class="line">if (window.XMLHttpRequest) &#123;</span><br><span class="line">	&#x2F;&#x2F;  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br><span class="line">	xmlhttp &#x3D; new XMLHttpRequest()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	&#x2F;&#x2F; IE6, IE5 浏览器执行代码</span><br><span class="line">	xmlhttp &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">	if (xmlhttp.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xmlhttp.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">		document.getElementById(&quot;myDiv&quot;).innerHTML &#x3D; xmlhttp.responseText</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(&quot;GET&quot;, &quot;&#x2F;ajax&#x2F;test.txt&quot;, true)</span><br><span class="line">xmlhttp.send()</span><br></pre></td></tr></table></figure>

<p>Ajax的常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.open方法：与服务器建立连接</span><br><span class="line">2.send方法：向服务器发送数据</span><br><span class="line">3.onreadystatechange：监听服务器响应的回调</span><br><span class="line">4.responseText&#x2F;responseXML：获取服务器响应的数据</span><br><span class="line">5.readyState：ajax的状态码，4表示ajax响应已经完成</span><br></pre></td></tr></table></figure>

<h4 id="11-Ajax和Fetch区别"><a href="#11-Ajax和Fetch区别" class="headerlink" title="11.Ajax和Fetch区别"></a>11.Ajax和Fetch区别</h4><ul>
<li>ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。</li>
<li>使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。+</li>
<li>在默认情况下，fetch不会接受或者发送cookies</li>
<li>fetch没有办法原生监测请求的进度，而XMLHttpRequest可以</li>
<li>fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</li>
<li>fetch不是在ajax上的封装，是ES6规范下的一种网络请求技术，兼容性上比不上XMLHttpRequest</li>
</ul>
<h4 id="12-ajax-的缺点"><a href="#12-ajax-的缺点" class="headerlink" title="12.ajax 的缺点"></a>12.ajax 的缺点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、ajax 不支持浏览器 back 按钮。</span><br><span class="line">2、安全问题 AJAX 暴露了与服务器交互的细节。</span><br><span class="line">3、对搜索引擎的支持比较弱。</span><br><span class="line">4、破坏了程序的异常机制。</span><br><span class="line">5、ajax跨域访问的问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="13-变量提升"><a href="#13-变量提升" class="headerlink" title="13.变量提升"></a>13.变量提升</h4><p>用var声明的变化会被自动提升。let和const不会使变量提升。</p>
<p>用var声明的变量会被提升到当前作用域的最前面，只会提升变量的声明，不会提升变量的赋值。</p>
<p>如果有函数的声明和变量的声明同名，则函数的提升会在变量的提升之前。</p>
<h4 id="14-cookie、localStorage、sessionStorage区别"><a href="#14-cookie、localStorage、sessionStorage区别" class="headerlink" title="14.cookie、localStorage、sessionStorage区别"></a>14.cookie、localStorage、sessionStorage区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命周期</td>
<td>一般由服务器生成，可以setMaxAge来设置cookie的有效时间，如果在浏览器生成，默认是关闭浏览器之后失效</td>
<td>永久保存，可清除</td>
<td>仅在当前会话有效，关闭页面后清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4KB</td>
<td>5MB</td>
<td>5MB</td>
</tr>
<tr>
<td>与服务器通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端保存</td>
<td>仅在客户端保存</td>
</tr>
<tr>
<td>用途</td>
<td>一般由服务器生成，用于标识用户身份</td>
<td>用于浏览器缓存数据</td>
<td>用于浏览器缓存数据</td>
</tr>
</tbody></table>
<h4 id="15-自调用函数-用于什么场景？好处"><a href="#15-自调用函数-用于什么场景？好处" class="headerlink" title="15.自调用函数?用于什么场景？好处?"></a>15.自调用函数?用于什么场景？好处?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">自调用函数:1、声明一个匿名函数2、马上调用这个匿名函数。</span><br><span class="line"></span><br><span class="line">自调用函数的作用：创建一个独立的作用域。</span><br><span class="line"></span><br><span class="line">自调用函数好处：防止变量的命名污染问题(同名的变量在多个地方声明多次)</span><br><span class="line"></span><br><span class="line">场景：一般用于框架、插件等场景</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="16-实现add函数-让add-a-b-和add-a-b-两种调用结果相同"><a href="#16-实现add函数-让add-a-b-和add-a-b-两种调用结果相同" class="headerlink" title="16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同"></a>16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    if (b &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        return function(x) &#123;</span><br><span class="line">            return a + x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="17-js中万物皆对象你认为对么"><a href="#17-js中万物皆对象你认为对么" class="headerlink" title="17.js中万物皆对象你认为对么"></a>17.js中万物皆对象你认为对么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s1 &#x3D; &quot;some text&quot;;   &#x2F;&#x2F;number     栈区</span><br><span class="line"></span><br><span class="line">var s3 &#x3D; s1.substring(2);    &#x2F;&#x2F;自动装箱</span><br><span class="line"></span><br><span class="line">var s2 &#x3D; new String();    &#x2F;&#x2F;引用类型(包装类型)  对象  堆区</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我认为是对的，在JS中有原生函数、基本数据类型，它们的原型最终还是对象。<br>可以看看本文的原生函数</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><a href="#JavaScript"></a></h4><h4 id="18-多个页面之间如何进行通信"><a href="#18-多个页面之间如何进行通信" class="headerlink" title="18.多个页面之间如何进行通信"></a>18.多个页面之间如何进行通信</h4><p>有如下几个方式：</p>
<ul>
<li>localStorage</li>
<li>cookie</li>
<li>postMessage API<br>支持两个页面跨域；只能传递字符串数据；参考 window.open；</li>
<li>url传参</li>
</ul>
<h4 id="19-css动画和js动画的差异"><a href="#19-css动画和js动画的差异" class="headerlink" title="19.css动画和js动画的差异"></a>19.css动画和js动画的差异</h4><ol>
<li>代码复杂度，js 动画代码相对复杂一些</li>
<li>动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件</li>
<li>动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41479807">https://zhuanlan.zhihu.com/p/41479807</a></p>
<h4 id="20-请用js去除字符串空格"><a href="#20-请用js去除字符串空格" class="headerlink" title="20.请用js去除字符串空格"></a>20.请用js去除字符串空格</h4><p>去除所有空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.replace(&#x2F;\s&#x2F;g, &#39;&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>去除字符串两边空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str.replace(&#x2F;^\s+|\s+$&#x2F;g, &#39;&#39;)</span><br><span class="line">&#x2F;&#x2F; 原生方法</span><br><span class="line">str.trim()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="21-new一个对象经历了什么"><a href="#21-new一个对象经历了什么" class="headerlink" title="21.new一个对象经历了什么"></a>21.new一个对象经历了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Test()&#123;&#125;</span><br><span class="line">const test &#x3D; new Test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个新对象：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置新对象的constructor属性为构造函数的名称，设置新对象的<code>__proto__</code>属性指向构造函数的prototype对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.constructor &#x3D; Test</span><br><span class="line">obj.__proto__ &#x3D; Test.prototype</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用新对象调用函数，函数中的this被指向新实例对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test.call(obj)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ol>
<h4 id="22-bind、call、apply的区别"><a href="#22-bind、call、apply的区别" class="headerlink" title="22.bind、call、apply的区别"></a>22.bind、call、apply的区别</h4><p>bind、call、apply可以改变被调用函数中的this指向。</p>
<p>call和apply其实是一样的，区别就在call需要一个个传参，而apply可以入参一个数组。</p>
<p>call和apply都是在调用时触发指定的方法，同时改变指定方法中的this指向。而bind是返回一个已经修改this指向后的新函数，如果要触发该方法，我们需要手动调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const newFunc &#x3D; sayHi.bind(obj)</span><br><span class="line">newFunc() &#x2F;&#x2F; Hi! Tom</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="23-JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？"><a href="#23-JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？" class="headerlink" title="23.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？"></a>23.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据类型主要包括两部分：</span><br><span class="line">1.基本数据类型： Undefined、Null、Boolean、Number和String</span><br><span class="line">2.引用数据类型： Array 、Object</span><br><span class="line"></span><br><span class="line">typeof运算符的结果类型：number,string，boolean,object,function,undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="24-null，undefined-的区别"><a href="#24-null，undefined-的区别" class="headerlink" title="24.null，undefined 的区别?"></a>24.null，undefined 的区别?</h4><p>null表示一个对象被定义了，值为“空值”；</p>
<p>undefined 表示不存在这个值(没有定义)。</p>
<p>null和undefined分属不同的类型，未初始化定义的值用typeof检测出来是”undefined”(字符串)，而null值用typeof检测出来是”object”（字符串）。</p>
<p>实际上，undefined值是派生自null值的，ECMAScript标准规定对二者进行相等性测试要返回true，即 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(null &#x3D;&#x3D; undefined);  &#x2F;&#x2F; true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="25-怎么判断一个变量没有被定义"><a href="#25-怎么判断一个变量没有被定义" class="headerlink" title="25.怎么判断一个变量没有被定义"></a>25.怎么判断一个变量没有被定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> bianliang ==”<span class="literal">undefined</span>”</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="★26-怎么判断一个变量arr的话是否为数组（此题用typeof不行）★"><a href="#★26-怎么判断一个变量arr的话是否为数组（此题用typeof不行）★" class="headerlink" title="★26.怎么判断一个变量arr的话是否为数组（此题用typeof不行）★"></a>★26.怎么判断一个变量arr的话是否为数组（此题用typeof不行）★</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过instanceof来判断</span></span><br><span class="line"><span class="comment">//instanceof : 作用判断某一个变量是否是指定类型的变量，返回结果是true  false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;<span class="comment">//返回true或者false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">	name:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">	age:<span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isArray (obj1))==&gt;<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArray (obj1))==&gt;<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过构造函数来判断是否是数组</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.constructor==<span class="built_in">Array</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过原型的toString()方法阿来判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o)== <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isArray(ary));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="27-描述下JSON对象的两个很重要的方法"><a href="#27-描述下JSON对象的两个很重要的方法" class="headerlink" title="27.描述下JSON对象的两个很重要的方法"></a>27.描述下JSON对象的两个很重要的方法</h4><p>JSON.parse() //JSON字符串转换为JSON对象</p>
<p>JSON.stringify() //JSON对象转化为字符串</p>
<h4 id="28-“-”、“-”的区别？"><a href="#28-“-”、“-”的区别？" class="headerlink" title="28.“ ===”、“ ==”的区别？"></a>28.“ ===”、“ ==”的区别？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.对于基本数据类型而言</span><br><span class="line">   &#x3D;&#x3D;，当且仅当两个运算数相等时，它返回 true，即不检查数据类型</span><br><span class="line">   &#x3D;&#x3D;&#x3D;，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型</span><br><span class="line">2.对应引用类型而言</span><br><span class="line">  &#x3D;&#x3D; 判断内存地址是否一致</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="29-eval是做什么的？"><a href="#29-eval是做什么的？" class="headerlink" title="29.eval是做什么的？"></a>29.eval是做什么的？</h4><p>它的功能是把对应的字符串解析成JS代码并运行；</p>
<p>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。</p>
<p>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>
<h4 id="30-简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容"><a href="#30-简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容" class="headerlink" title="30.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容"></a>30.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用事件委托的方式给ul绑定点击事件</span><br><span class="line">$(“ul”).on(“click”,”li”,function()&#123;</span><br><span class="line">	$(this).html(“hit”);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="31-简述下为何通过ajax发送的请求会出现乱码问题，如何解决？"><a href="#31-简述下为何通过ajax发送的请求会出现乱码问题，如何解决？" class="headerlink" title="31.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？"></a>31.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？</h4><p>乱码的问题就是编码格式冲突，我们需要传输中文数据前面加一个encodeURI()编码，例如：encodeURI($(“#fk_info”).val())；在接受参数的页面对传过来的编码过后的内容用后端语言进行解码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node后台向其他服务器发送请求</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://www.baidu.com/?name=张三&quot;</span>;</span><br><span class="line"><span class="comment">//这里我们需要将中文的  张三  编码后发给服务器</span></span><br><span class="line">url = <span class="built_in">encodeURI</span>(url);</span><br><span class="line">request(url,<span class="function"><span class="keyword">function</span>(<span class="params">error,response,body</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!error &amp;&amp; response.statusCode == <span class="number">200</span></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//输出返回的内容</span></span><br><span class="line">        <span class="built_in">console</span>.log(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="32-简述DOM，HTML-DOM的区别和联系"><a href="#32-简述DOM，HTML-DOM的区别和联系" class="headerlink" title="32.简述DOM，HTML DOM的区别和联系"></a>32.简述DOM，HTML DOM的区别和联系</h4><p>DOM分为三部分：</p>
<p>（1）核心DOM：遍历DOM树、添加新节点、删除节点、修改节点</p>
<p>（2）HTML DOM：以一种简便的方法访问DOM树</p>
<p>（3）XML DOM：准用于操作XML文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">核心DOM与HTML DOM的区别：</span><br><span class="line">A.核心DOM(dom对象) ： Document,Node,  ElementNode,TextNode,AttributeNode，CommentNode,NodeList</span><br><span class="line"></span><br><span class="line">核心DOM提供了统一的操作接口，如：createElement、appendChild、setAttribute等</span><br><span class="line">核心DOM创建新元素：var newNode&#x3D;document.createElement(&quot;img&quot;)</span><br><span class="line">给元素添加属性：e.setAttribure()、e.setAttribureNode()</span><br><span class="line">适用场合：核心DOM适合操作节点，如创建，删除，查找等</span><br><span class="line"></span><br><span class="line">B.HTML DOM(js对象)：image,Table,Form,Input,Select等等HTML标签对象化</span><br><span class="line">使用HTML DOM创建新元素：  var newNode &#x3D; new Image()；</span><br><span class="line">使用给元素添加属性：</span><br><span class="line">img.src&#x3D;&#39;&#39;;</span><br><span class="line">img.id&#x3D;&#39;&#39;;</span><br><span class="line">imd.title&#x3D;&#39;&#39;;</span><br><span class="line">img.className&#x3D;&#39;&#39;</span><br><span class="line">img.style.display&#x3D;&#39;&#39;;</span><br><span class="line"></span><br><span class="line">适用场合：</span><br><span class="line">HTML DOM适合操作属性，如读取或修改属性的值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="33-什么是事件流"><a href="#33-什么是事件流" class="headerlink" title="33.什么是事件流"></a>33.什么是事件流</h4><pre><code>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。DOM同时支持两种事件模型：捕获型事件和冒泡型事件

el.addEventListener(&quot;click&quot;, function()&#123;&#125;,false);   //事件冒泡阶段
el.addEventListener(&quot;click&quot;, function()&#123;&#125;,true);    //事件捕获阶段</code></pre>
<h4 id="34-JavaScript原型继承是如何运作的？"><a href="#34-JavaScript原型继承是如何运作的？" class="headerlink" title="34.JavaScript原型继承是如何运作的？"></a>34.JavaScript原型继承是如何运作的？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.什么是原型链</span><br><span class="line">  对象.__propto__ &#x3D; 函数.prototype</span><br><span class="line">  函数.prototype.__proto__ &#x3D; 父亲的.prototype</span><br><span class="line"></span><br><span class="line">  原型链中属性的查找规则如下：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去(知道找到null为止)，也就是我们平时所说的原型链的概念。</span><br><span class="line"></span><br><span class="line">2.原型继承是对原型链做了相应的修改</span><br><span class="line"></span><br><span class="line">3.举个例子 </span><br><span class="line">   Dog.prototype &#x3D; new Animal()</span><br><span class="line">   var dog &#x3D; new Dog()</span><br><span class="line">   dog.__proto__ &#x3D;&#x3D; Dog.prototype</span><br><span class="line">   &#x2F;&#x2F;原来 Dog.prototype.__proto__ &#x3D;&#x3D; 父亲的.prototype</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F;现在 dog.__proto__ &#x3D;&#x3D; new Animal()</span><br><span class="line">   &#x2F;&#x2F;然后 new Animal().__proto__ &#x3D;&#x3D; Animal.prototype;</span><br><span class="line">   &#x2F;&#x2F;所以原型链被修改了</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="35-DOM元素Attribute与Property的区别是什么？"><a href="#35-DOM元素Attribute与Property的区别是什么？" class="headerlink" title="35.DOM元素Attribute与Property的区别是什么？"></a>35.DOM元素Attribute与Property的区别是什么？</h4><p>1、 property是DOM中的属性，是JavaScript里的对象；而attribute是HTML标签上的特性，它的值只能够是字符串；</p>
<p>2、DOM对象初始化时会在创建默认的基本property；只有在HTML标签中定义的attribute才会被保存在property的attributes属性中；</p>
<p>3、attribute会初始化property中的同名属性，但自定义的attribute不会出现在property中；</p>
<p>4、propety是对象，而attribute的值都是字符串；</p>
<h4 id="36-指出下面代码的区别"><a href="#36-指出下面代码的区别" class="headerlink" title="36.指出下面代码的区别"></a>36.指出下面代码的区别</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Order</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> order = Order();      （<span class="number">1</span>）</span><br><span class="line"><span class="keyword">var</span> order = <span class="keyword">new</span> Order();  （<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"><span class="number">1.</span>代码（<span class="number">1</span>）是将函数Order()作为一个普通函数去调用的</span><br><span class="line"><span class="number">2.</span>代码（<span class="number">2</span>）是将Order()作为一个构造函数去调用的；</span><br><span class="line"><span class="number">3.</span>当函数Order的方法体中有<span class="built_in">this</span>关键之的时候，作为普通函数<span class="built_in">this</span>指的是<span class="built_in">window</span>对象，作为构造函数存在的时候<span class="built_in">this</span>指代的是本对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="37-document-ready-是个什么函数？为什么要用它。"><a href="#37-document-ready-是个什么函数？为什么要用它。" class="headerlink" title="37.$(document).ready()是个什么函数？为什么要用它。"></a>37.$(document).ready()是个什么函数？为什么要用它。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.$(document).ready()这个函数是用来取代页面中的window.onload; 不同的是onload()的方法是在页面加载完成后才发生，这包括DOM元素和其他页面元素（例如图片）的加载，而document.ready()是在dom准备就绪后执行。因此，使用document.ready()方法的执行速度比onload()的方法要快。</span><br><span class="line"></span><br><span class="line">2.如果使用onload，那么页面中只能写一个onload函数，如果写多个，后面的onload会覆盖前面的onload。但是如果使用$(document).ready()，那么我们可以写多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="39-请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20"><a href="#39-请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20" class="headerlink" title="39.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20."></a>39.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答案： &#x2F;^[A-Za-z_]\w&#123;4,19&#125;$&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="40-JS中原型链最上层的对象是-object-的原型对象，该对象的-proto-指针指向-null-的原型对象。"><a href="#40-JS中原型链最上层的对象是-object-的原型对象，该对象的-proto-指针指向-null-的原型对象。" class="headerlink" title="40.JS中原型链最上层的对象是  object  的原型对象，该对象的_proto_指针指向  null    的原型对象。"></a>40.JS中原型链最上层的对象是  object  的原型对象，该对象的<code>_proto_</code>指针指向  null    的原型对象。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="42-JS中使用-Object-对象的-defineProperty-函数定义对象属性的访问器。"><a href="#42-JS中使用-Object-对象的-defineProperty-函数定义对象属性的访问器。" class="headerlink" title="42.JS中使用 Object 对象的   defineProperty    函数定义对象属性的访问器。"></a>42.JS中使用 Object 对象的   defineProperty    函数定义对象属性的访问器。</h4><p>使用Object.defineProperty()方法可以做数据的劫持，当我们使用Object.defineProperty()定义了对象的属性之后，给对象赋值的时候会执行set方法，获取对象值的时候会执行get方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, &#39;name&#39;, &#123;</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    return temp</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (val) &#123;</span><br><span class="line">    temp &#x3D; val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.name &#x3D; &quot;张三&quot;；                   执行set（）方法</span><br><span class="line">console.log(person.name);               执行get（）方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="43-如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）"><a href="#43-如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）" class="headerlink" title="43.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）"></a>43.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）</h4><p>将这篇文章以字符串的形式赋给一个变量。定义一个正则表达式，以全局匹配的方式查找所有敏感词，并用replace方法替换掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var rep&#x3D;&#x2F;cao|草|曹操|妈&#x2F;g;</span><br><span class="line">console.log(text1.value.replace(rep,&#39;*&#39;));  &#x2F;&#x2F;将相关的敏感词用*替换</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="44-添加、删除、更改、插入节点的方法"><a href="#44-添加、删除、更改、插入节点的方法" class="headerlink" title="44.添加、删除、更改、插入节点的方法"></a>44.添加、删除、更改、插入节点的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendChild</span><br><span class="line">removeChild</span><br><span class="line">replaceChild</span><br><span class="line">insertBefore</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="45-在javascript编程中，请至少说出三种异步操作的使用场景？"><a href="#45-在javascript编程中，请至少说出三种异步操作的使用场景？" class="headerlink" title="45.在javascript编程中，请至少说出三种异步操作的使用场景？"></a>45.在javascript编程中，请至少说出三种异步操作的使用场景？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;异步操作的场景：</span><br><span class="line"></span><br><span class="line">1.读文件  :   fs.readFile(&quot;path&quot;,&quot;utf-8&quot;,function()&#123;&#125;)</span><br><span class="line">2.事件监听 :</span><br><span class="line">    element.addEventListener(“click”,function()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,false); </span><br><span class="line">3.网络请求 :</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:&quot;&quot;,</span><br><span class="line">        method:&quot;GET&quot;,</span><br><span class="line">        success:function(res)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;异步问题的解决方案：</span><br><span class="line">&#x2F;&#x2F;1.基于回调的异步请求解决方案</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.基于Promise</span><br><span class="line">console.log(&quot;2&quot;)</span><br><span class="line">new Promise(function(resolve,reject)&#123;</span><br><span class="line">    console.log(&quot;1&quot;);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&quot;4&quot;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;,500);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&quot;5&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;3&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.Async和await</span><br><span class="line">async function test()&#123;</span><br><span class="line">    let result1 &#x3D; await axios(&quot;url1&quot;)</span><br><span class="line">    let result2 &#x3D; await axios(&quot;url2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">加async修饰的方法，里面可以使用await，方法的返回值需要是一个promise</span><br><span class="line">await只能出现在async修饰的方法里面，await后面需要跟一个promise</span><br><span class="line">async + await 可以将原来的并行任务转换串行任务</span><br><span class="line">比如上面的例子，result2的结果要等到result1请求结束之后才能执行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="46-知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写"><a href="#46-知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写" class="headerlink" title="46.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写"></a>46.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">事件冒泡:父元素和子元素上面的话都添加的有click（不仅仅是click事件，只要保证是同一个事件即可）。子元素的click事件触发的时候，会导致该click事件冒泡到它的父元素上面，为了阻止父元素的事件触发，我们一般需要给子元素的事件里写上阻止事件冒泡的方法</span><br><span class="line"></span><br><span class="line">兼容性写法：</span><br><span class="line">if(event.stopPropagation)&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;else if(event.cancelBubble)&#123;</span><br><span class="line">    event.cancelBubble &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阻止浏览器默认行为:当我们不希望一些浏览器默认行为触发的时候，就需要给对应的事件添加上阻止浏览器默认行为。比如我们给a标签绑定click事件，当a标签的click事件触发之后，仍然会执行a标签自己的href</span><br><span class="line"></span><br><span class="line">兼容性写法：</span><br><span class="line">function cDefault(e)&#123;</span><br><span class="line">    if(e.preventDefault)&#123;&#x2F;&#x2F;ie9+</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;else&#123;&#x2F;&#x2F;ie 678</span><br><span class="line">   		e.returnValue &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="47-什么是闭包（closure），为什么要用它？"><a href="#47-什么是闭包（closure），为什么要用它？" class="headerlink" title="47.什么是闭包（closure），为什么要用它？"></a>47.什么是闭包（closure），为什么要用它？</h4><p>闭包就是函数嵌套函数，并将该内部函数作为返回值返回或者存储在某个对象的属性里，这时就会形成一个闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = aa();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用途：</span><br><span class="line">1.缓存，延长变量的作用域链</span><br><span class="line">2.面向对象中的对象</span><br><span class="line">3.实现封装，防止变量跑到外层作用域中，发生命名冲突</span><br><span class="line"></span><br><span class="line">危害：</span><br><span class="line">1.闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当的话会内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</span><br><span class="line">2.性能问题，使用闭包时，会涉及到跨作用域访问，由于闭包内部变量优先级高于外部变量，所以多查找作用域链中的一个层次，就会在一定程度上影响查找速度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="48-知道原型和原型链么，一般什么时候需要用？"><a href="#48-知道原型和原型链么，一般什么时候需要用？" class="headerlink" title="48.知道原型和原型链么，一般什么时候需要用？"></a>48.知道原型和原型链么，一般什么时候需要用？</h4><p>函数有一个prototype属性，叫原型属性。主要作用有两个：1.共享所有实例公共的属性和方法。2.继承</p>
<p>当我们有一个属性/方法需要被所有实例共享的时候，我们可以使用prototype</p>
<p>当我们需要实现js的继承关系的时候，我们可以使用prototype</p>
<p>原型链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对象.__proto__ &#x3D;&#x3D; 函数.prototyoe</span><br><span class="line">函数.prototyoe.__proto__ &#x3D;&#x3D; 父函数.prototype</span><br><span class="line">父函数.prototype.__proto__ &#x3D;&#x3D; 父父函数.prototype</span><br><span class="line">...</span><br><span class="line">父父父函数.prototype &#x3D;&#x3D; Object.prototype</span><br><span class="line">Object.prototype.__proto__ &#x3D;&#x3D; null</span><br><span class="line"></span><br><span class="line">这样就构成了原型链</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="49-有没有封装过插件，你一般怎么封装呢"><a href="#49-有没有封装过插件，你一般怎么封装呢" class="headerlink" title="49.有没有封装过插件，你一般怎么封装呢"></a>49.有没有封装过插件，你一般怎么封装呢</h4><p>封装过，我们主要用面向对象中的混合模式来封装插件，把可变的属性或者方法（通常都是属性）在构造函数内定义，把一些不变的属性或者方法（通常是方法）定义在函数的原型上面。我们封装好的插件通常会放在一个匿名自执行函数里面，这样做的目的是为了避免变量冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(()&#x3D;&gt;&#123;</span><br><span class="line">    function  Snake()&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.nnx  &#x3D; name;</span><br><span class="line"></span><br><span class="line">        say()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Snake.prototype.xx &#x3D; xxx</span><br><span class="line">    window.Snake &#x3D; Snake;</span><br><span class="line">&#125;)(window)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="50-Ajax和jsonp的原理？"><a href="#50-Ajax和jsonp的原理？" class="headerlink" title="50.Ajax和jsonp的原理？"></a>50.Ajax和jsonp的原理？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ajax的原理：Ajax基于浏览器内置的XMLHttpRequest对象与Web服务器端进行异步数据通信。</span><br><span class="line">1.使用open方法与服务器建立连接</span><br><span class="line">2.使用send方法向服务器发送数据</span><br><span class="line">3.使用onreadystatechange来监听服务器响应的回调</span><br><span class="line">4.使用responseText&#x2F;responseXML获取服务器响应的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JSONP：是通过动态创建 script 标签向服务器发送请求获取响应的一种技术，在服务器需要返回一段JS脚本给客户端，客户端收到JS脚本立马执行对应的代码。为此，服务器应该设置响应头为 application&#x2F;javascript</span><br><span class="line"></span><br><span class="line">JSONP和Ajax没有任何关系。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="51-你们移动端怎么开发的？用的什么单位、js库呢、怎么真机调试你们程序、怎么解决前缀问题呢"><a href="#51-你们移动端怎么开发的？用的什么单位、js库呢、怎么真机调试你们程序、怎么解决前缀问题呢" class="headerlink" title="51.你们移动端怎么开发的？用的什么单位、js库呢、怎么真机调试你们程序、怎么解决前缀问题呢"></a>51.你们移动端怎么开发的？用的什么单位、js库呢、怎么真机调试你们程序、怎么解决前缀问题呢</h4><p>首先我们移动端用的是rem这个单位，移动端实际上还新增了vw,vh等一些单位，但是相对于rem来说，他们的兼容性都不好。rem是一个相对单位，是相对于根节点的font-size的比例。我们还会引用一个外部的js，这个js可以通过屏幕宽度动态计算根节点的font-size值。</p>
<p>我们移动端用的JS库是zepto.js，因为相应来说它的的体积的话要小很多。而且我们项目中有时会需要使用一些触屏事件，比如滑动事件，那么我们还会调用它里面的touch模块</p>
<p>我们webapp的话都是基于gulp搭建的前端工程来开发，因为利用gulp起一个webserver特别简单，并且我还可以实现livereload功能（当我监控的文件发生变化的时候，可以触发浏览器的自动刷新功能），而且在css3里面加前缀的话是一个很头疼的问题，我们现在只需要用autoprefixer模块就可以很容易实现自动加css3前缀这个功能了。</p>
<h4 id="52-移动端兼容性？"><a href="#52-移动端兼容性？" class="headerlink" title="52.移动端兼容性？"></a>52.移动端兼容性？</h4><p>bootstrap中起步中有：</p>
<p>1&gt;ios移动端click事件300ms的延迟响应. 用fastclick来解决</p>
<p>2&gt;zepto的touch模块的tap事件有点透的问题，也是用fastclick来解决</p>
<p>3&gt;一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了</p>
<p>4&gt;ios下取消input在输入的时候英文首字母的默认大写</p>
<pre><code>&lt;input autocapitalize=&quot;off&quot;autocorrect=&quot;off&quot; /&gt;</code></pre>
<p>5&gt;fixed定位缺陷</p>
<pre><code>ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位
android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位
ios4下不支持position:fixed

解决方案： 可用iScroll插件解决这个问题</code></pre>
<p>6&gt;Input 的placeholder会出现文本位置偏上的情况</p>
<pre><code>input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal</code></pre>
<p>7&gt;calc的兼容性处理</p>
<pre><code> CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。
 Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸：

div &#123;
    width: 95%;
    width: -webkit-calc(100% - 50px);
    width: calc(100% - 50px);
&#125;</code></pre>
<p>8&gt;在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：</p>
<pre><code>\ &#123;-webkit-tap-highlight-color:rgba(0,0,0,0);&#125;</code></pre>
<p>9&gt;阻止旋转屏幕时自动调整字体大小</p>
<pre><code>html, body, form, fieldset, p, div, h1, h2, h3, h4, h5,h6 &#123;-webkit-text-size-adjust:none;&#125;</code></pre>
<h4 id="53-谈谈你对bootstrap的认识，用它做过项目么？"><a href="#53-谈谈你对bootstrap的认识，用它做过项目么？" class="headerlink" title="53.谈谈你对bootstrap的认识，用它做过项目么？"></a>53.谈谈你对bootstrap的认识，用它做过项目么？</h4><p>用Bootstrap主要用来做一些响应式的网站，它里面栅格化这块比较强大，我可以针对不同的屏幕尺寸定制不同页面结构。</p>
<p>我还用它做过后台管理系统，因为它里面集成的有风格标准统一的组件、插件、全局样式等，是我们做后台管理系统的话，不用再花大精力去布局页面了。而且甚至产品给我们一个原型图我们就可以开始开发，大大提高了开发效率。</p>
<h4 id="54-javascript-继承的方法？"><a href="#54-javascript-继承的方法？" class="headerlink" title="54.javascript 继承的方法？"></a>54.javascript 继承的方法？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>借助构造函数实现继承</span><br><span class="line">    <span class="comment">//  定义父类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  定义子类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//通过call()方法改变Child1的this指向使子类的函数体内执行父级的构造函数从而实现继承效果</span></span><br><span class="line">        Parent1.call(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">this</span>.address = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  构建子类的实例s1</span></span><br><span class="line">    <span class="keyword">var</span> s1 = <span class="keyword">new</span> Child1()</span><br><span class="line">    <span class="built_in">console</span>.log(s1.name)  <span class="comment">//xxx</span></span><br><span class="line">	缺点:该方法的实力(s1)无法使用父类(Parent1)的原型(prototype)中的属性和方法</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>借助原型链实现继承</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">19</span>,</span><br><span class="line">        <span class="built_in">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  一样在父类添加say方法</span></span><br><span class="line">    Parent2.prototype = &#123;</span><br><span class="line">        say () &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child2</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.address = <span class="string">&#x27;yyy&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让子类的构造函数原型直接指向父类实例</span></span><br><span class="line">    Child2.prototype = <span class="keyword">new</span> Parent2()</span><br><span class="line">    <span class="comment">//  生成两个子类的实例s2、s3</span></span><br><span class="line">    <span class="keyword">var</span> s2 = <span class="keyword">new</span> Child2()</span><br><span class="line">    <span class="keyword">var</span> s3 = <span class="keyword">new</span> Child2()</span><br><span class="line">    <span class="comment">// s2实例继承了父类中的name属性 </span></span><br><span class="line">    <span class="built_in">console</span>.log(s2.name)  <span class="comment">//xx</span></span><br><span class="line">    <span class="comment">//  s2实例也同样继承了父类原型上的say方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(s2.say())  <span class="comment">//say</span></span><br><span class="line">	缺点:在子类调用构造函数创建对象的时候，无法入参所有的属性值</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span>组合继承</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent5</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&#x27;xx&#x27;</span>,</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">20</span>,</span><br><span class="line">        <span class="built_in">this</span>.play = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child5</span> (<span class="params">name,age,address</span>) </span>&#123;</span><br><span class="line">        Parent5.call(<span class="built_in">this</span>,name,age)</span><br><span class="line">        <span class="built_in">this</span>.address = address</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较关键的一步</span></span><br><span class="line">    Child5.prototype = <span class="keyword">new</span> Parent5()</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> Child5(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">19</span>,<span class="string">&quot;无锡&quot;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="number">4.</span>实例继承(为父类实例添加新特性，作为子类实例返回)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      <span class="built_in">this</span>.name = name || <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">      <span class="comment">// 实例方法</span></span><br><span class="line">      <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法</span></span><br><span class="line">    Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> instance = <span class="keyword">new</span> Animal();</span><br><span class="line">      instance.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Test Code</span></span><br><span class="line">    <span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    <span class="built_in">console</span>.log(cat.name);</span><br><span class="line">    <span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line">    <span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>拷贝继承</span><br><span class="line">    <span class="comment">// 定义一个动物类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      <span class="built_in">this</span>.name = name || <span class="string">&#x27;Animal&#x27;</span>;</span><br><span class="line">      <span class="comment">// 实例方法</span></span><br><span class="line">      <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法</span></span><br><span class="line">    Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">     <span class="comment">// 遍历拷贝属性</span></span><br><span class="line">      <span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> p <span class="keyword">in</span> animal</span>)</span>&#123;</span><br><span class="line">        Cat.prototype[p] = animal[p];</span><br><span class="line">      &#125;</span><br><span class="line">      Cat.prototype.name = name || <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test Code</span></span><br><span class="line">    <span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    <span class="built_in">console</span>.log(cat.name);</span><br><span class="line">    <span class="built_in">console</span>.log(cat.sleep());</span><br><span class="line">    <span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="55-简述创建函数的几种方式"><a href="#55-简述创建函数的几种方式" class="headerlink" title="55.简述创建函数的几种方式"></a>55.简述创建函数的几种方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第一种（函数声明）：</span><br><span class="line">function sum1(num1,num2)&#123;</span><br><span class="line">	return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第二种（函数表达式）：</span><br><span class="line">var sum2 &#x3D; function(num1,num2)&#123;</span><br><span class="line">	return num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第三种(匿名函数)：</span><br><span class="line">function()&#123;&#125;:只能自己执行自己</span><br><span class="line"></span><br><span class="line">第四种(new Function创建函数)</span><br><span class="line">let str &#x3D; &#39;return &#39; + &#39;&#96;Hello $&#123;name&#125;!&#96;&#39;;</span><br><span class="line">let func &#x3D; new Function(&#39;name&#39;, str);</span><br><span class="line">func(&#39;Jack&#39;) &#x2F;&#x2F; &quot;Hello Jack!&quot;</span><br></pre></td></tr></table></figure>

<h4 id="56-把-Script-标签-放在页面的最底部的-body-封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？"><a href="#56-把-Script-标签-放在页面的最底部的-body-封闭之前-和封闭之后有什么区别？浏览器会如何解析它们？" class="headerlink" title="56.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？"></a>56.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.建议把script标签放在body封闭之前</span><br><span class="line">2.从HTML2.0开始，在&lt;&#x2F;body&gt;之后插入其他元素就符合标准。</span><br><span class="line">3.按照HTML5标准中的HTML语法规则，如果在&lt;&#x2F;body&gt;后再出现&lt;script&gt;或任何元素的开始标签，都是parse error，浏览器会忽略之前的&lt;&#x2F;body&gt;，即视作仍旧在body内。所以实际效果和写在&lt;&#x2F;body&gt;之前是没有区别的。</span><br><span class="line">4.虽然把script标签放在&lt;&#x2F;body&gt;之后也能work，但是并没有带来任何额外好处，会把&lt;&#x2F;body&gt;给忽略掉，给浏览器造成了额外的工作，所以还是不要这样写为好</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="57-js-延迟加载的方式有哪些？"><a href="#57-js-延迟加载的方式有哪些？" class="headerlink" title="57.js 延迟加载的方式有哪些？"></a>57.js 延迟加载的方式有哪些？</h4><ol>
<li><p>defer 和 async :    js文件的加载不会堵塞DOM的解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. defer 属性</span><br><span class="line">&lt;script  src&#x3D;&quot;file.js&quot; defer&gt;&lt;&#x2F;script&gt; </span><br><span class="line">defer属性声明这个脚本中将不会有 document.write 或 dom 修改。</span><br><span class="line">浏览器将会并行下载 file.js 和其它有 defer 属性的script，而不会阻塞页面后续处理。</span><br><span class="line"> </span><br><span class="line">defer属性在IE 4.0中就实现了，超过13年了！Firefox 从 3.5 开始支持defer属性 。</span><br><span class="line">注：所有的defer 脚本保证是按顺序依次执行的。</span><br><span class="line"></span><br><span class="line">2. async 属性</span><br><span class="line">&lt;script src&#x3D;&quot;file.js&quot; async&gt;&lt;&#x2F;script&gt; </span><br><span class="line">async属性是HTML5新增的。作用和defer类似，但是它将在下载后尽快执行，不能保证脚本会按顺序执行。它们将在onload 事件之前完成。</span><br><span class="line">Firefox 3.6、Opera 10.5、IE 9 和 最新的Chrome 和 Safari 都支持 async 属性。可以同时使用 async 和 defer，这样IE 4之后的所有 IE 都支持异步加载。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ga &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">ga.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">ga.async &#x3D; true;</span><br><span class="line">ga.src &#x3D; &#39;xxxx&#39;;</span><br><span class="line">var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0];</span><br><span class="line">s.parentNode.insertBefore(ga, s);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于JavaScript的动态性，还有很多异步加载方法： XHR Injection、 XHR Eval、 Script In Iframe</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17550381/article/details/80925793">https://blog.csdn.net/qq_17550381/article/details/80925793</a></p>
</li>
</ol>
<h4 id="58-数组方法-pop-push-unshift-shift-各表示什么意思？"><a href="#58-数组方法-pop-push-unshift-shift-各表示什么意思？" class="headerlink" title="58.数组方法 pop() push() unshift() shift()各表示什么意思？"></a>58.数组方法 pop() push() unshift() shift()各表示什么意思？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答：push()尾部添加、pop()尾部删除、Unshift()头部添加、shift()头部删除</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="59-Javascript-中-callee-和-caller-的作用？"><a href="#59-Javascript-中-callee-和-caller-的作用？" class="headerlink" title="59.Javascript 中 callee 和 caller 的作用？"></a>59.Javascript 中 callee 和 caller 的作用？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caller 是返回一个对函数的引用，该函数调用了当前函数；</span><br><span class="line">用法：fn.caller</span><br><span class="line"></span><br><span class="line">callee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。</span><br><span class="line">用法：arguments.callee</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="60-jQuery-extend-与-jQuery-fn-extend-的区别？"><a href="#60-jQuery-extend-与-jQuery-fn-extend-的区别？" class="headerlink" title="60.jQuery.extend 与 jQuery.fn.extend 的区别？"></a>60.jQuery.extend 与 jQuery.fn.extend 的区别？</h4><p>$.fn = $.prototype ，原型中的属性和方法是所有的实例对象共享的</p>
<p>jQuery.extend 用来扩展 jQuery 对象本身(所扩展的方法只能被当前的jQuery对象访问)</p>
<p>jQuery.fn.extend 是在 jQuery 原型对象上扩展方法，此时该方法可以被所有的jQuery对象共享</p>
<h4 id="61-jQuery-和-Zepto-的区别？各自的使用场景？"><a href="#61-jQuery-和-Zepto-的区别？各自的使用场景？" class="headerlink" title="61.jQuery 和 Zepto 的区别？各自的使用场景？"></a>61.jQuery 和 Zepto 的区别？各自的使用场景？</h4><p>jQuery 主要用于 pc 端，当然有对应的 jQuery mobile 用于移动端</p>
<p>zepto 比 jQuery 更加小巧，主要用于移动端</p>
<p>jquery mobile 相对于 zepto 功能强大，但是体积也很庞大，zepto 非常的轻量</p>
<h4 id="62-Zepto-的点透问题如何解决？"><a href="#62-Zepto-的点透问题如何解决？" class="headerlink" title="62.Zepto 的点透问题如何解决？"></a>62.Zepto 的点透问题如何解决？</h4><p>点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()，这个时候当点击上面的 div 的时候就会影响到下面的那个 div；</p>
<p>解决办法：github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应</p>
<h4 id="63-事件绑定和普通事件有什么区别"><a href="#63-事件绑定和普通事件有什么区别" class="headerlink" title="63.事件绑定和普通事件有什么区别"></a>63.事件绑定和普通事件有什么区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">div1.onclick&#x3D;function()&#123;&#125;;</span><br><span class="line">1、如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定</span><br><span class="line">2、不支持 DOM 事件流 事件捕获阶段&#x3D;&gt;目标元素阶段&#x3D;&gt;事件冒泡阶段</span><br><span class="line"></span><br><span class="line">addEventListener</span><br><span class="line">1、 如果说给同一个元素绑定了两次或者多次相同类型的事件，所有的绑定将会依次触发</span><br><span class="line">2、 支持 DOM 事件流的</span><br><span class="line">3、 进行事件绑定传参不需要 on 前缀</span><br><span class="line"></span><br><span class="line">addEventListener(“click”,function()&#123;&#125;,true);&#x2F;&#x2F;此时的事件就是在事件冒泡阶段执行</span><br><span class="line">ie9 开始，ie11 edge：addEventListener &#x2F;removeEventListener</span><br><span class="line">ie9 以前：attachEvent&#x2F;detachEvent</span><br><span class="line">1、 进行事件类型传参需要带上 on 前缀</span><br><span class="line">2、 这种方式只支持事件冒泡，不支持事件捕获</span><br><span class="line">事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="64-IE-和标准模式下有哪些兼容性的写法"><a href="#64-IE-和标准模式下有哪些兼容性的写法" class="headerlink" title="64.IE 和标准模式下有哪些兼容性的写法"></a>64.IE 和标准模式下有哪些兼容性的写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ev &#x3D; ev || window.event</span><br><span class="line">document.documentElement.clientWidth || document.body.clientWidth</span><br><span class="line">var target &#x3D; ev.srcElement||ev.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="65-iframe-的优缺点？"><a href="#65-iframe-的优缺点？" class="headerlink" title="65.iframe 的优缺点？"></a>65.iframe 的优缺点？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">iframe的优点：</span><br><span class="line">1.iframe能够原封不动的把嵌入的网页展现出来，iframe和主页面是并行加载的</span><br><span class="line">2.如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</span><br><span class="line">3.网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</span><br><span class="line">4.如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</span><br><span class="line"></span><br><span class="line">iframe的缺点：</span><br><span class="line">1.会产生很多页面，不容易管理。</span><br><span class="line">2.iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。</span><br><span class="line">3.代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。</span><br><span class="line">4.很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。</span><br><span class="line">5.iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。</span><br><span class="line">6.iframe会堵塞主页面的onload事件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="66-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#66-DOM-操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="66.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点"></a>66.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. 创建新节点</span><br><span class="line">createDocumentFragment() &#x2F;&#x2F; 创建一个 DOM 片段</span><br><span class="line">createElement() &#x2F;&#x2F; 创建一个具体的元素</span><br><span class="line">createTextNode() &#x2F;&#x2F; 创建一个文本节点</span><br><span class="line"></span><br><span class="line">2. 添加、移除、替换、插入</span><br><span class="line">appendChild()</span><br><span class="line">removeChild()</span><br><span class="line">replaceChild()</span><br><span class="line">insertBefore() &#x2F;&#x2F; 在已有的子节点前插入一个新的子节点</span><br><span class="line"></span><br><span class="line">3. 查找</span><br><span class="line">getElementsByTagName() &#x2F;&#x2F; 通过标签名称</span><br><span class="line">getElementsByName() &#x2F;&#x2F; 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组，</span><br><span class="line">其中包括 id 等于 name 值的)</span><br><span class="line">getElementById() &#x2F;&#x2F; 通过元素 Id，唯一性</span><br></pre></td></tr></table></figure>

<h4 id="67-documen-write-和-innerHTML-的区别？"><a href="#67-documen-write-和-innerHTML-的区别？" class="headerlink" title="67.documen.write 和 innerHTML 的区别？"></a>67.documen.write 和 innerHTML 的区别？</h4><p>document.write 只能重绘整个页面<br>innerHTML 可以重绘页面的一部分</p>
<h4 id="68-哪些操作会造成内存泄漏？"><a href="#68-哪些操作会造成内存泄漏？" class="headerlink" title="68.哪些操作会造成内存泄漏？"></a>68.哪些操作会造成内存泄漏？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</span><br><span class="line">垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</span><br><span class="line"></span><br><span class="line">1. setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</span><br><span class="line">2. 闭包</span><br><span class="line">3. 控制台日志</span><br><span class="line">4. 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</span><br></pre></td></tr></table></figure>

<h4 id="69-window-location-search-返回的是什么？"><a href="#69-window-location-search-返回的是什么？" class="headerlink" title="69.window.location.search 返回的是什么？"></a>69.window.location.search 返回的是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面, 并使用 javascript 来获得相信应的参数值。</span><br><span class="line"></span><br><span class="line">返回值：?ver&#x3D;1.0&amp;id&#x3D;timlq 也就是问号后面的！</span><br></pre></td></tr></table></figure>

<h4 id="70-window-location-hash-返回的是什么？"><a href="#70-window-location-hash-返回的是什么？" class="headerlink" title="70.window.location.hash 返回的是什么？"></a>70.window.location.hash 返回的是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：锚点  #后面的</span><br></pre></td></tr></table></figure>

<h4 id="71-window-location-reload-作用？"><a href="#71-window-location-reload-作用？" class="headerlink" title="71.window.location.reload() 作用？"></a>71.window.location.reload() 作用？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：刷新当前页面。</span><br></pre></td></tr></table></figure>

<h4 id="72-BOM-对象有哪些，列举-window-对象？"><a href="#72-BOM-对象有哪些，列举-window-对象？" class="headerlink" title="72.BOM 对象有哪些，列举 window 对象？"></a>72.BOM 对象有哪些，列举 window 对象？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、window 对象 ，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；</span><br><span class="line">2、document 对象，文档对象；</span><br><span class="line">3、location 对象，浏览器当前 URL 信息；</span><br><span class="line">4、navigator 对象，浏览器本身信息；</span><br><span class="line">5、screen 对象，客户端屏幕信息；</span><br><span class="line">6、history 对象，浏览器访问历史信息；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="73-请问代码实现-outerHTML"><a href="#73-请问代码实现-outerHTML" class="headerlink" title="73.请问代码实现 outerHTML"></a>73.请问代码实现 outerHTML</h4><p>说明：outerHTML 其实就是 innerHTML 再加上本身；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.outerHTML &#x3D; function()&#123;</span><br><span class="line">    var innerCon &#x3D; this.innerHTML, &#x2F;&#x2F;获得里面的内容</span><br><span class="line">    outerCon &#x3D; this.appendChild(innerCon); &#x2F;&#x2F;添加到里面</span><br><span class="line">    alert(outerCon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="74-你如何优化自己的代码？"><a href="#74-你如何优化自己的代码？" class="headerlink" title="74.你如何优化自己的代码？"></a>74.你如何优化自己的代码？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代码重用 (封装)</span><br><span class="line">避免全局变量（模块化 mvc..）</span><br><span class="line">拆分函数避免函数过于臃肿：单一职责原则</span><br><span class="line">适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程</span><br><span class="line">内存管理，尤其是闭包中的变量释放</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="75-列举常用的-js-库以及分别适用的领域"><a href="#75-列举常用的-js-库以及分别适用的领域" class="headerlink" title="75.列举常用的 js 库以及分别适用的领域"></a>75.列举常用的 js 库以及分别适用的领域</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jquery：简化了 js 的一些操作，并且提供了一些非常好用的 API</span><br><span class="line">jquery ui、jquery-easyui：在 jqeury 的基础上提供了一些常用的组件 日期，下拉框，表格这</span><br><span class="line">些组件</span><br><span class="line">require.js、sea.js（阿里的玉帛）+》模块化开发使用的</span><br><span class="line">zepto：精简版的 jquery，常用于手机 web 前端开发 提供了一些手机页面实用功能,touch</span><br><span class="line">ext.js：跟 jquery 差不多，但是不开源，也没有 jquery 轻量</span><br><span class="line">swiper.js</span><br><span class="line">iscroll.js</span><br><span class="line">angular、vue、react、flutter：MV*框架，适合用于单页应用开发(SPA)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="76-JavaScript-数组元素添加、删除、排序等方法有哪些？"><a href="#76-JavaScript-数组元素添加、删除、排序等方法有哪些？" class="headerlink" title="76.JavaScript 数组元素添加、删除、排序等方法有哪些？"></a>76.JavaScript 数组元素添加、删除、排序等方法有哪些？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Array.concat( ) 连接数组</span><br><span class="line">Array.join( ) 将数组元素连接起来以构建一个字符串</span><br><span class="line">Array.length 数组的大小</span><br><span class="line">Array.pop( ) 删除并返回数组的最后一个元素</span><br><span class="line">Array.push( ) 给数组添加元素</span><br><span class="line">Array.reverse( ) 颠倒数组中元素的顺序</span><br><span class="line">Array.shift( ) 将元素移出数组</span><br><span class="line">Array.slice( ) 返回数组的一部分</span><br><span class="line">Array.sort( ) 对数组元素进行排序</span><br><span class="line">Array.splice( ) 插入、删除或替换数组的元素</span><br><span class="line">Array.toLocaleString( ) 把数组转换成局部字符串</span><br><span class="line">Array.toString( ) 将数组转换成一个字符串</span><br><span class="line">Array.unshift( ) 在数组头部插入一个元素</span><br><span class="line"></span><br><span class="line">Array.map()</span><br><span class="line">Array.some()</span><br><span class="line">Array.forEach()</span><br><span class="line">Array.every()</span><br><span class="line">Array.reduce()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="77-如何添加-html-元素的事件，有几种方法？请列举"><a href="#77-如何添加-html-元素的事件，有几种方法？请列举" class="headerlink" title="77.如何添加 html 元素的事件，有几种方法？请列举"></a>77.如何添加 html 元素的事件，有几种方法？请列举</h4><p>a、直接在标签里使用onclick添加<br>b、在元素上通过 js 添加:  obj.onclick = method<br>c、使用事件注册函数添加: obj.addEventListener(‘click’, method, false);</p>
<h4 id="78-使用闭包实现点击每一列的时候-alert-其-index？"><a href="#78-使用闭包实现点击每一列的时候-alert-其-index？" class="headerlink" title="78.使用闭包实现点击每一列的时候 alert 其 index？"></a>78.使用闭包实现点击每一列的时候 alert 其 index？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;这是第一条&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;这是第二条&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;这是第三条&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">var lis&#x3D;document.querySelectorAll(&#39;li&#39;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    var li &#x3D; lis[i];</span><br><span class="line">    &#x2F;&#x2F;自调用函数</span><br><span class="line">    li.onclick &#x3D; (function(index)&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">            alert(index);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="79-列出-3-条以上-ff-和-IE-的脚本兼容问题"><a href="#79-列出-3-条以上-ff-和-IE-的脚本兼容问题" class="headerlink" title="79.列出 3 条以上 ff 和 IE 的脚本兼容问题"></a>79.列出 3 条以上 ff 和 IE 的脚本兼容问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1、在 IE 下和火狐下事件冒泡不一样</span><br><span class="line">&#x2F;&#x2F;阻止冒泡的兼容性写法</span><br><span class="line">function stopBubble(event)&#123;</span><br><span class="line">    var e&#x3D;arguments.callee.caller.arguments[0]||event;</span><br><span class="line">    if(e&amp;&amp;e.stopPropagation)&#123;</span><br><span class="line">        e.stopPropagation()</span><br><span class="line">    &#125;else if(window.event)&#123;</span><br><span class="line">    	&#x2F;&#x2F;ie</span><br><span class="line">        window.event.cancelBubble&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;阻止浏览器默认行为的兼容性写法</span><br><span class="line">function stopDefault(event)&#123;</span><br><span class="line">    var e&#x3D;arguments.callee.caller.arguments[0]||event;</span><br><span class="line">    &#x2F;&#x2F;阻止默认浏览器动作(W3C)</span><br><span class="line">    if(e&amp;&amp;e.preventDefault)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        &#x2F;&#x2F;IE中阻止函数默认动作的方式</span><br><span class="line">        window.event.returnValue&#x3D;false;      </span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、IE 的写法： tbody&#x3D;table.childNodes[0]</span><br><span class="line">	在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白</span><br><span class="line">	可以通过 if(&quot;&quot; !&#x3D; node.nodeName)过滤掉空白子对象</span><br><span class="line"></span><br><span class="line">3、模拟点击事件</span><br><span class="line">if(document.all)&#123; &#x2F;&#x2F;ie 下</span><br><span class="line">	document.getElementById(&quot;a3&quot;).click();</span><br><span class="line">&#125;</span><br><span class="line">else&#123; &#x2F;&#x2F;非 IE</span><br><span class="line">	var evt &#x3D; document.createEvent(&quot;MouseEvents&quot;);</span><br><span class="line">	evt.initEvent(&quot;click&quot;, true, true);</span><br><span class="line">	document.getElementById(&quot;a3&quot;).dispatchEvent(evt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、事件注册</span><br><span class="line">if (isIE)&#123;</span><br><span class="line">   window.attachEvent(&quot;onload&quot;, init);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">   window.addEventListener(&quot;load&quot;, function()&#123;&#125;)</span><br><span class="line"></span><br><span class="line">5、ajax对象的获取</span><br><span class="line">   IE： ActiveXObject</span><br><span class="line">   其他浏览器：XMLHttpRequest</span><br><span class="line"></span><br><span class="line">6、firstElement等返回结果不一样</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="80-在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#80-在-Javascript-中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="80.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？"></a>80.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">伪数组（类数组）：有数组的部分特性，比如length、下标索引等，但是无法像数组一样调用数组的方法。典型伪数组有：函数的argument参数、getElementsByTagName、document.childNodes返回的dom集合、jquery对象等等。</span><br><span class="line"></span><br><span class="line">虽然伪数组不可以直接调用真正数组的方法，但是我们可以使用 Array.prototype.slice.call(fakeArray)来间接调用真正数组的方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="81-正则表达式构造函数-var-reg-new-RegExp-“xxx”-与正则表达字面量-var-reg-有什么不同？匹配邮箱的正则表达式？"><a href="#81-正则表达式构造函数-var-reg-new-RegExp-“xxx”-与正则表达字面量-var-reg-有什么不同？匹配邮箱的正则表达式？" class="headerlink" title="81.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 var reg=//有什么不同？匹配邮箱的正则表达式？"></a>81.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 var reg=//有什么不同？匹配邮箱的正则表达式？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.当使用 RegExp()构造函数的时候，需要转义符号（比如即\”表示”）</span><br><span class="line">2.var reg&#x3D;&#x2F;&#x2F; 使用正则表达字面量的效率更高。</span><br><span class="line"></span><br><span class="line">\d  数字</span><br><span class="line">\w  数字、字母、下划线</span><br><span class="line">\s   空白字符</span><br><span class="line">\b  单词边界</span><br><span class="line">n+  至少1个</span><br><span class="line">n?  0个或1个</span><br><span class="line">n*  0个或多个</span><br><span class="line">[a-z]  a到z</span><br><span class="line">[^a-z] 非a-z</span><br><span class="line"></span><br><span class="line">邮箱正则： ^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="82-jQuery-的-slideUp-动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢"><a href="#82-jQuery-的-slideUp-动画-，如果目标元素是被外部事件驱动-当鼠标快速地连续触发外部元素事件-动画会滞后的反复执行，该如何处理呢" class="headerlink" title="82.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?"></a>82.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先 stop(true,true)后 slideUp()</span><br><span class="line">stop(&quot;是否清空动画队列&quot;,“是否来到动画结束的状态”)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="83-javascript-的本地对象，内置对象和宿主对象"><a href="#83-javascript-的本地对象，内置对象和宿主对象" class="headerlink" title="83.javascript 的本地对象，内置对象和宿主对象"></a>83.javascript 的本地对象，内置对象和宿主对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.本地对象为独立于宿主环境的 ECMAScript 提供的对象，包括 Array Object RegExp 等可以 new 实例化的对象</span><br><span class="line">2.内置对象为 Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)</span><br><span class="line">3.宿主对象为所有的非本地对象，所有的 BOM 和 DOM 对象都是宿主对象，如浏览器自带的document,window 等对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="84-请说出三种减低页面加载时间的方法"><a href="#84-请说出三种减低页面加载时间的方法" class="headerlink" title="84.请说出三种减低页面加载时间的方法"></a>84.请说出三种减低页面加载时间的方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>减少http请求数量和体积</span><br><span class="line">	-压缩 css、js 文件</span><br><span class="line">	-合并 js、css 文件，减少 http 请求</span><br><span class="line">	-使用CSS Sprites图，合并多个CSS图片，合理使用图片压缩</span><br><span class="line">	-合理使用http缓存，减少http请求</span><br><span class="line">	-使用外部的css和js以减少服务器的压力</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>css和script的位置</span><br><span class="line">	把 css 样式引入放在&lt;head&gt;标签中，把 &lt;script&gt;资源引入放在&lt;/body&gt;闭合之前。</span><br><span class="line">	外链脚本在加载时却常常阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。所以说尽可能的将脚本往后挪，减少对并发下载的影响</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span>DOM操作优化</span><br><span class="line">	-要避免在<span class="built_in">document</span>上直接进行频繁的DOM操作(用innerHTML代替DOM操作)，缓存DOM节点查找的结果</span><br><span class="line">	-使用classname代替大量的内联样式修改</span><br><span class="line">	-对于复杂的UI元素，设置position为absolute或fixed</span><br><span class="line">	-在js动画和css动画之间尽量使用css动画</span><br><span class="line">	-适当使用canvas</span><br><span class="line">	-使用事件代理</span><br><span class="line">	-避免使用<span class="built_in">eval</span>或<span class="built_in">Function</span>，每次 <span class="built_in">eval</span> 或 <span class="built_in">Function</span> 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码，这是很消耗资源的操作 </span><br><span class="line">    -避免大量的字符串拼接，可以使用数组的join方法</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>CSS选择符优化</span><br><span class="line">	-避免使用通配符选择器，避免使用后代选择器</span><br><span class="line">	-选择器匹配是从右向左匹配的，选择器语句链越短，浏览器的匹配速度越快</span><br><span class="line">	-避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作</span><br><span class="line">	-搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）。在写样式时，避免触发重新布局的可能</span><br><span class="line">	-减少使用昂贵的属性，所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价。box-shadow/border-radius/filter/透明度/:nth-child等</span><br><span class="line">	-不要使用@<span class="keyword">import</span></span><br><span class="line">    -尽量减少css表达式的使用  background-color: expression((<span class="keyword">new</span> <span class="built_in">Date</span>()).getHours()%<span class="number">2</span>?<span class="string">&quot;#FFFFFF&quot;</span>: <span class="string">&quot;#000000&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//附：重排和重绘的操作</span></span><br><span class="line">-重排的操作：</span><br><span class="line">    width	height	padding	margin</span><br><span class="line">    display	border-width	border	top</span><br><span class="line">    position	font-size	float	text-align</span><br><span class="line">    overflow-y	font-weight	overflow	left</span><br><span class="line">    font-family	line-height	vertical-align	right</span><br><span class="line">    clear	white-space	bottom	min-height</span><br><span class="line">    offsetTop  offsetLeft  offsetWidth   offsetHeight</span><br><span class="line">    scrollTop   scrollLeft  scrollWidth   scrollHeight</span><br><span class="line">    clientTop   clientLeft   clientWidth  clientHeight </span><br><span class="line">    getComputedStyle()    (currentStyle <span class="keyword">in</span> IE)</span><br><span class="line"> -重绘的操作：</span><br><span class="line"> 	color	border-style	visibility	background</span><br><span class="line">	text-decoration	background-image	background-position	background-repeat</span><br><span class="line">	outline-color	outline	outline-style	border-radius</span><br><span class="line">	outline-width	box-shadow	background-size</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="85-Javascript-作用域链"><a href="#85-Javascript-作用域链" class="headerlink" title="85.Javascript 作用域链?"></a>85.Javascript 作用域链?</h4><p>JavaScript有全局作用域和函数作用域，没有块作用域(es6中使用let声明的变量有块级作用域)，函数的嵌套形成不同层次的作用域，嵌套的层次形成作用域链。</p>
<p>作用域链:变量的使用,从里向外,层层的搜索,搜索到了就可以直接使用了。层层搜索,搜索到0级作用域的时候,如果还是没有找到这个变量,结果就是报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">	&#x2F;&#x2F;1级作用域</span><br><span class="line">    var num &#x3D; 123;</span><br><span class="line">    function f2() &#123;</span><br><span class="line">    	&#x2F;&#x2F;2级作用域</span><br><span class="line">        console.log( num );</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;0级作用域</span><br><span class="line">var num &#x3D; 456;</span><br><span class="line">f1();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="G:/Workspace/Z-前端面试题/Front-end-knowledge/assets/1567057970491.png" alt="1567057970491"></p>
<h4 id="86-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？"><a href="#86-javascript-代码中的”use-strict”-是什么意思-使用它区别是什么？" class="headerlink" title="86.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？"></a>86.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？</h4><p>意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">链接：http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;2013&#x2F;01&#x2F;javascript_strict_mode.html</span><br><span class="line"></span><br><span class="line">全局变量显式声明</span><br><span class="line">静态绑定</span><br><span class="line">禁止使用 with 语句</span><br><span class="line">eval 中定义的变量都是局部变量</span><br><span class="line">禁止 this 关键字指向全局对象</span><br><span class="line">禁止在函数内部遍历调用栈</span><br><span class="line">严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除</span><br><span class="line">正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，</span><br><span class="line">将报错。</span><br><span class="line">严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。</span><br><span class="line">严格模式下，对禁止扩展的对象添加新属性，会报错。</span><br><span class="line">严格模式下，删除一个不可删除的属性，会报错。</span><br><span class="line">正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，</span><br><span class="line">这属于语法错误。</span><br><span class="line">正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于</span><br><span class="line">语法错误。</span><br><span class="line">正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严</span><br><span class="line">格模式禁止这种表示法，整数第一位为 0，将报错。</span><br><span class="line">不允许对 arguments 赋值</span><br><span class="line">arguments 不再追踪参数的变化</span><br><span class="line">禁止使用 arguments.callee</span><br><span class="line">严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的</span><br><span class="line">代码块内声明函数</span><br><span class="line">严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">严格模式的一些主要优点包括：</span><br><span class="line">- 使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。(实时显示错误代码，方便调试)</span><br><span class="line">- 防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。(如果一个变量在没声明就赋值，这个变量会自动变成全局变量，防止意外)</span><br><span class="line">- 消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。</span><br><span class="line">- 不允许重复的属性名称或参数值。当检测到对象（例如，var object &#x3D; &#123;foo: &quot;bar&quot;, foo: &quot;baz&quot;&#125;;）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1)&#123;&#125;）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。(避免重复命名，变量，参数，等)</span><br><span class="line">- 使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。(eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。)</span><br><span class="line">- 在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="87-Javascript-中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"><a href="#87-Javascript-中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？" class="headerlink" title="87.Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？"></a>87.Javascript 中，有一个函数，执行对象查找时，永远不会去查找原型，这个函数是？</h4><p>hasOwnProperty</p>
<h4 id="88-js模块化规范"><a href="#88-js模块化规范" class="headerlink" title="88.js模块化规范"></a>88.js模块化规范</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#requirejs  AMD前台模块化规范</span><br><span class="line"><span class="number">1</span>、引入模块</span><br><span class="line"><span class="built_in">require</span>([dependencies],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line">    - 第一个参数是一个数组,表示所依赖的模块</span><br><span class="line">- 第二个参数是一个回调函数,当前面指定的模块都加载成功后,它将被调用.加载的模块会以参数形式传入该函数,从而在回调函数内部就可以使用这些模块</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、定义模块</span><br><span class="line">define(id?,dependencies?,factory);</span><br><span class="line">    - id: 定义中模块的名字;可选；如果没有提供该参数,模块的名字应该默认为模块加载器请求的指定脚本的名字.</span><br><span class="line">    - 依赖dependencies：是一个当前模块依赖的,已被模块定义的模块标识的数组字面量</span><br><span class="line">    - 工厂方法factory,模块初始化要执行的函数或对象.如果为函数,它应该只被执行一次.如果是对象,此对象应该为模块的输出值.</span><br><span class="line">    - 默认情况下文件名即为模块名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#seajs   CMD前台模块化规范</span><br><span class="line"><span class="comment">//声明模块</span></span><br><span class="line">define(id?,d?,factory)</span><br><span class="line">- id : 因为CMD推崇一个文件一个模块,所以经常就用文件名作为模块id</span><br><span class="line">- d : CMD推崇依赖就近,所以一般不在define的参数中写依赖</span><br><span class="line">- factory :函数   <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>,<span class="built_in">exports</span>,<span class="built_in">module</span></span>)</span></span><br><span class="line"><span class="function">        <span class="title">require</span> 是一个方法,用来获取其他模块提供的接口</span></span><br><span class="line"><span class="function">        <span class="title">exports</span> 是一个对象,用来向外提供模块接口</span></span><br><span class="line"><span class="function">        <span class="title">module</span> 是一个对象,上面存储了与当前模块相关联的一些属性和方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//使用模块</span></span><br><span class="line"><span class="function"><span class="title">seajs</span>.<span class="title">use</span>(<span class="params"><span class="string">&#x27;mymodel.js&#x27;</span>,<span class="keyword">function</span>(mymodel)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#commonjs   后台模块化规范</span><br><span class="line"><span class="comment">//1.模块的引入</span></span><br><span class="line"><span class="keyword">const</span> modu = <span class="built_in">require</span>(‘./b.js’)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.模块的导出</span></span><br><span class="line"><span class="comment">//导出单个成员</span></span><br><span class="line"><span class="built_in">exports</span>.foo = “变量”</span><br><span class="line"><span class="built_in">exports</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出多个成员</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ES6模块化规范</span><br><span class="line"><span class="comment">//1.导出</span></span><br><span class="line"><span class="comment">//导出单个成员</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> name= <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> kk = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//导出多个成员</span></span><br><span class="line"><span class="keyword">export</span> &#123;name, age&#125;;</span><br><span class="line"><span class="comment">//导出默认成员</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> kk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.引入</span></span><br><span class="line"><span class="keyword">import</span> kk,&#123;name,age&#125; <span class="keyword">from</span> <span class="string">&#x27;a.js&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="89-gulp、grunt、webpack"><a href="#89-gulp、grunt、webpack" class="headerlink" title="89.gulp、grunt、webpack"></a>89.gulp、grunt、webpack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp、grunt、webpack都是前端自动化构建工具。gulp 和 grunt 非常类似，gulp强调的是前端开发的工作流程，核心都是基于一个个的任务(task)进行项目构建，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程</span><br><span class="line"></span><br><span class="line">Webpack与Gulp、Grunt没有什么可比性，它把项目看成一个整体，是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。webpack is a module bundle</span><br></pre></td></tr></table></figure>

<h4 id="90-requireJS-的核心原理是什么？"><a href="#90-requireJS-的核心原理是什么？" class="headerlink" title="90.requireJS 的核心原理是什么？"></a>90.requireJS 的核心原理是什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存。是AMD模块化规范的实现。</span><br></pre></td></tr></table></figure>

<h4 id="91-AMD（requirejs）、CMD（seajs）区别"><a href="#91-AMD（requirejs）、CMD（seajs）区别" class="headerlink" title="91.AMD（requirejs）、CMD（seajs）区别"></a>91.AMD（requirejs）、CMD（seajs）区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CMD 推崇依赖就近;AMD 推崇依赖前置</span><br><span class="line">2.CMD 是延迟执行,懒加载;AMD 是提前执行</span><br><span class="line">3.CMD性能好,因为只有用户需要的时候才执行;AMD用户体验好,因为没有延迟,依赖模块提前执行了</span><br></pre></td></tr></table></figure>

<h4 id="92-谈一谈你对-ECMAScript6-的了解"><a href="#92-谈一谈你对-ECMAScript6-的了解" class="headerlink" title="92.谈一谈你对 ECMAScript6 的了解"></a>92.谈一谈你对 ECMAScript6 的了解</h4><p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>
<p>一、新增箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 简化了写法， 少打代码，结构清晰</span><br><span class="line">- 明确了<span class="built_in">this</span>。传统JS的<span class="built_in">this</span>是在运行的时候确定的，而不是在定义的时候确定的；而箭头函数的<span class="built_in">this</span>是在定义时就确定的，不能被改变，也不能被call,apply,bind这些方法修改。      </span><br></pre></td></tr></table></figure>

<p>二、块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- ES6中的<span class="keyword">let</span>声明的变量有块级作用域</span><br><span class="line">- ES5中是没有块级作用域的，并且<span class="keyword">var</span>有变量提升的概念</span><br><span class="line">- <span class="keyword">let</span>声明的变量在同一个作用域内只有一个</span><br><span class="line">- 要声明常量使用<span class="keyword">const</span></span><br></pre></td></tr></table></figure>

<p>三、解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ES6中变量的解构赋值，比如：</span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>:abc,bar&#125; = &#123;<span class="attr">foo</span>:<span class="string">&#x27;hello&#x27;</span>,<span class="attr">bar</span>:<span class="string">&#x27;hi&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>四、Symbol</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6新增了一种Symbol数据类型，表示全局唯一的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a1 === a2);   <span class="comment">//false   a1和a2永远不相等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a3 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;a3&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> a4 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;a3&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a3 === a4);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>五、模板字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> gender=<span class="string">&quot;男&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`姓名<span class="subst">$&#123;name&#125;</span>,年龄<span class="subst">$&#123;age&#125;</span>,性别<span class="subst">$&#123;gender&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>六、展开运算符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1,...arr2];</span><br></pre></td></tr></table></figure>

<p>七、类</p>
<p>ES6引入Class这个概念，让JS拥有其他面向对象语言的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 继承传递参数</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name=<span class="string">&#x27;mukewang&#x27;</span></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name=<span class="string">&#x27;child&#x27;</span></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//先初始化父亲的信息，在初始化自己的信息  </span></span><br><span class="line">      <span class="built_in">super</span>(name);</span><br><span class="line">      <span class="built_in">this</span>.type=<span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;继承传递参数&#x27;</span>,<span class="keyword">new</span> Child(<span class="string">&#x27;hello&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>八、Promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ES6的Promise主要用于解决JS回调地狱问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filePath, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pReadFile(<span class="string">&#x27;./data/a.txt&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">&#x27;./data/b.txt&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">&#x27;./data/c.txt&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>九、ES6的迭代器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for ... of 是ES6中新增加的语法,主要用来循环实现了Iterator接口类型的对象</span></span><br><span class="line"><span class="comment">//for ... of 可以遍历Array、Set、Map不能遍历Object </span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;America&#x27;</span>, <span class="string">&#x27;Korea&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o) <span class="comment">//China, America, Korea</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>十、ES6模块化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导出</span></span><br><span class="line"><span class="comment">//导出单个成员</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> name= <span class="string">&#x27;leo&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> age= <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> kk = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">//导出多个成员</span></span><br><span class="line"><span class="keyword">export</span> &#123;name, age&#125;;</span><br><span class="line"><span class="comment">//导出默认成员</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> kk;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.引入</span></span><br><span class="line"><span class="keyword">import</span> kk,&#123;name,age&#125; <span class="keyword">from</span> <span class="string">&#x27;a.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="93-Object-对象的常用方法"><a href="#93-Object-对象的常用方法" class="headerlink" title="93.Object 对象的常用方法"></a>93.Object 对象的常用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.hasOwnProperty( ) 检查属性是否被继承</span><br><span class="line">Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型</span><br><span class="line">Object.propertyIsEnumerable( ) 是否可以通过 for&#x2F;in 循环看到属性</span><br><span class="line">Object.toLocaleString( ) 返回对象的本地字符串表示</span><br><span class="line">Object.toString( ) 定义一个对象的字符串表示</span><br><span class="line">Object.valueOf( )  指定对象的原始值</span><br></pre></td></tr></table></figure>

<h4 id="94-如何编写高性能的-Javascript？"><a href="#94-如何编写高性能的-Javascript？" class="headerlink" title="94.如何编写高性能的 Javascript？"></a>94.如何编写高性能的 Javascript？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用 DocumentFragment 优化多次 append</span><br><span class="line">通过模板元素 clone ，替代 createElement</span><br><span class="line">使用一次 innerHTML 赋值代替构建 dom 元素</span><br><span class="line">使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素</span><br><span class="line">使用 Array 做为 StringBuffer ，代替字符串拼接的操作</span><br><span class="line">将循环控制量保存到局部变量</span><br><span class="line">顺序无关的遍历时，用 while 替代 for</span><br><span class="line">将条件分支，按可能性顺序从高到低排列</span><br><span class="line">在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if</span><br><span class="line">使用三目运算符替代条件分支</span><br><span class="line">需要不断执行的时候，优先考虑使用 setInterval</span><br></pre></td></tr></table></figure>

<h4 id="95-说说你对-this-的理解？"><a href="#95-说说你对-this-的理解？" class="headerlink" title="95.说说你对 this 的理解？"></a>95.说说你对 this 的理解？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">在 JavaScript 中，<span class="built_in">this</span> 通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 普通函数调用，此时 <span class="built_in">this</span> 指向 <span class="built_in">window</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    fn();  <span class="comment">//  window.fn(),此处默认省略window</span></span><br><span class="line"><span class="number">2.</span> 定时器函数， 此时 <span class="built_in">this</span> 指向 <span class="built_in">window</span></span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="number">3.</span> 构造函数调用， 此时 <span class="built_in">this</span> 指向 实例对象</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">// 此处 this 分别指向 Person 的实例对象 p1 p2</span></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="number">18</span>, <span class="string">&#x27;zs&#x27;</span>);</span><br><span class="line"><span class="number">4.</span> 对象方法调用， 此时 <span class="built_in">this</span> 指向 该方法所属的对象</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.fn();</span><br><span class="line"><span class="number">5.</span>通过事件绑定的方法， 此时 <span class="built_in">this</span> 指向 绑定事件的对象 </span><br><span class="line">    btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// btn</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6.</span>箭头函数的<span class="built_in">this</span>：是声明函数时所在作用域中的<span class="built_in">this</span></span><br><span class="line">	<span class="comment">//this   window</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="comment">//this</span></span><br><span class="line">        fn:  <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);   <span class="comment">//window</span></span><br><span class="line">        &#125;,</span><br><span class="line">        fn2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//this     obj</span></span><br><span class="line">            (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">//obj</span></span><br><span class="line">            &#125;)()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj.fn();</span><br><span class="line">	obj.fn2();</span><br></pre></td></tr></table></figure>

<h4 id="96-分别阐述-split-slice-splice-join-？"><a href="#96-分别阐述-split-slice-splice-join-？" class="headerlink" title="96.分别阐述 split(),slice(),splice(),join()？"></a>96.分别阐述 split(),slice(),splice(),join()？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔</span><br><span class="line">符，默认是以逗号分开。归属于 Array</span><br><span class="line">split()即把字符串分离开，以数组方式存储。归属于 Stringstring</span><br><span class="line">slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子</span><br><span class="line">数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()</span><br><span class="line">splice() 方法向&#x2F;从数组中添加&#x2F;删除项目，然后返回被删除的项目。返回的是含有被删除</span><br><span class="line">的元素的数组。</span><br></pre></td></tr></table></figure>

<h4 id="97-jQuery-fn-的-init-方法返回的-this-指的是什么对象？为什么要返回-this？"><a href="#97-jQuery-fn-的-init-方法返回的-this-指的是什么对象？为什么要返回-this？" class="headerlink" title="97.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？"></a>97.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this 执行 init 构造函数自身，其实就是 jQuery 实例对象，返回 this 是为了实现 jQuery</span><br><span class="line">的链式操作</span><br></pre></td></tr></table></figure>

<h4 id="98-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#98-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="98.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>98.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4><p>递归赋值</p>
<h4 id="99-实现一个sum函数，使其同时满足以下两个调用需求"><a href="#99-实现一个sum函数，使其同时满足以下两个调用需求" class="headerlink" title="99.实现一个sum函数，使其同时满足以下两个调用需求"></a>99.实现一个sum函数，使其同时满足以下两个调用需求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) sum(2,3)   &#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">(2) sum(2)(3)   &#x2F;&#x2F;5</span><br></pre></td></tr></table></figure>

<p>函数柯里化：实际上就是把sum函数的a，b两个参数变成了先用一个函数接收a，然后返回一个函数去处理b参数。现在思路应该就比较清晰了，就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="100-let、const、var区别和使用"><a href="#100-let、const、var区别和使用" class="headerlink" title="100.let、const、var区别和使用"></a>100.let、const、var区别和使用</h4><ol>
<li>var 声明的变量属于函数作用域，let 和 const 声明的变量属于块级作用域；</li>
<li>var 存在变量提升现象，而 let 和 const 没有此类现象；</li>
<li>var 变量可以重复声明，而在同一个作用域中，let 变量不能重新声明，const 变量不能修改。</li>
</ol>
<h4 id="101-“1”-”2”-”3”-map-parseInt-答案是多少，并写下分析过程"><a href="#101-“1”-”2”-”3”-map-parseInt-答案是多少，并写下分析过程" class="headerlink" title="101.[“1”,”2”,”3”].map(parseInt)答案是多少，并写下分析过程"></a>101.[“1”,”2”,”3”].map(parseInt)答案是多少，并写下分析过程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答案：[<span class="number">1</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br><span class="line">map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。map() 方法按照原始数组元素顺序依次处理元素。</span><br><span class="line"><span class="built_in">parseInt</span>()函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)。其中 radix 表示要解析的数字的基数。【该值介于 <span class="number">2</span> ~ <span class="number">36</span> 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;</span><br><span class="line">因为 <span class="built_in">parseInt</span> 需要两个参数 (val, radix),但 map 传了 <span class="number">3</span> 个 (element, index, array)</span><br><span class="line">即原例子相当于:</span><br><span class="line">　　[<span class="built_in">parseInt</span>(<span class="string">&quot;1&quot;</span>,<span class="number">0</span>),<span class="built_in">parseInt</span>(<span class="string">&quot;2&quot;</span>,<span class="number">1</span>),<span class="built_in">parseInt</span>(<span class="string">&quot;3&quot;</span>,<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(‘<span class="number">1</span>’, <span class="number">0</span>); <span class="comment">// 1 (radix 为 0 时，且 val 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1)</span></span><br><span class="line"><span class="built_in">parseInt</span>(‘<span class="number">2</span>’, <span class="number">1</span>); <span class="comment">// NaN (1 进制表示的数中，最大值小于 2，所以无法解析，返回 NaN)</span></span><br><span class="line"><span class="built_in">parseInt</span>(‘<span class="number">3</span>’, <span class="number">2</span>); <span class="comment">// NaN (但是二进制里面没有3，因此返回NaN)</span></span><br><span class="line">　　</span><br><span class="line">所以最后结果是[<span class="number">1</span>,<span class="literal">NaN</span>,<span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure>

<h4 id="102-分别一句话介绍，Cookie和Session是什么，两者的区别和关系？"><a href="#102-分别一句话介绍，Cookie和Session是什么，两者的区别和关系？" class="headerlink" title="102.分别一句话介绍，Cookie和Session是什么，两者的区别和关系？"></a>102.分别一句话介绍，<code>Cookie</code>和<code>Session</code>是什么，两者的区别和关系？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie和Session是服务器开发中会话管理的数据存储技术。Cookie和Session的主要区别如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. cookie 大小只有4k , seesion 大小有5M</span><br><span class="line">2. session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息</span><br><span class="line">3. session中保存的是对象，cookie中保存的是字符串</span><br><span class="line">4. session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。而cookie中如果设置 了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。</span><br><span class="line">5. session默认需要借助cookie才能正常工作。一个客户端的cookie只能拿到服务器中对应的session数据。客户端没有cookie是拿不到session数据的。</span><br><span class="line">6. session在用户会话结束后就会关闭了，但cookie因为保存在客户端，设定的期限内保存</span><br></pre></td></tr></table></figure>

<h4 id="103-一句话解释Bootstrap的栅格系统？"><a href="#103-一句话解释Bootstrap的栅格系统？" class="headerlink" title="103.一句话解释Bootstrap的栅格系统？"></a>103.一句话解释<code>Bootstrap</code>的栅格系统？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap内置了一套响应式、移动设备优先的流式栅格系统，随着屏幕设备或视口（viewport）尺寸的增加，会将屏幕分为最多12列。它包含了易于使用的预定义class，比如col-md-6 col-xs-6 col-lg-6等等，还有强大的mixin用于生成更具语义的布局。</span><br></pre></td></tr></table></figure>

<h4 id="104-decodeURL的用处"><a href="#104-decodeURL的用处" class="headerlink" title="104.decodeURL的用处"></a>104.decodeURL的用处</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当URI中有中文或者特殊符号/ &amp;的时候，此时浏览器会对URI进行编码</span><br><span class="line"></span><br><span class="line">对URI进行解码有三种方式：<span class="built_in">decodeURI</span>()  <span class="built_in">decodeURIComponent</span>()   <span class="built_in">escape</span>()</span><br><span class="line">对URI进行编码的方式：   <span class="built_in">encodeURI</span>()  <span class="built_in">encodeURIComponent</span>()   <span class="built_in">unescape</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一资源标识符，或叫做 URI，是用来标识互联网上的资源（例如，网页或文件）和怎样访问这些资源的传输协议（例如，HTTP 或 FTP）的字符串。除了encodeURI、encodeURIComponent、decodeURI、decodeURIComponent四个用来编码和解码 URI 的函数之外 ECMAScript 语言自身不提供任何使用 URL 的支持。</span></span><br></pre></td></tr></table></figure>

<h4 id="105-简述javascript的内存管理，例如：什么时候触发垃圾回收，基础GC方案，以及GC的缺点等"><a href="#105-简述javascript的内存管理，例如：什么时候触发垃圾回收，基础GC方案，以及GC的缺点等" class="headerlink" title="105.简述javascript的内存管理，例如：什么时候触发垃圾回收，基础GC方案，以及GC的缺点等"></a>105.简述javascript的内存管理，例如：什么时候触发垃圾回收，基础GC方案，以及GC的缺点等</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">js中垃圾收集机制原理：垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）， 周期性地执行这一操作：找出那些不再继续使用的变量，然后释放其占用的内存。</span><br><span class="line"><span class="number">1.</span>引用计数机法</span><br><span class="line">原理：当JavaScript代码生成一个新的内存驻留项时（比如一个对象或函数），系统就会为这个项留出一块内存空间。因为这个对象可能会被传递给很多函数，并且会被指定给很多变量，所以很多代码都会指向这个对象的内存空间。JavaScript会跟踪这些指针，当最后一个指针废弃不用时，这个对象占用的内存会被释放。</span><br><span class="line">缺点：</span><br><span class="line">    <span class="number">1.</span>内存泄漏问题(内存泄漏是指程序中己动态分配的堆*内存*由于某种原因程序未释放或无法释放，造成系统*内存*的浪	  费，导致程序运行速度减慢甚至系统崩溃等严重后果。)</span><br><span class="line">    <span class="number">2.</span>循环引用问题</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>标记清除法</span><br><span class="line"><span class="comment">//标记清除算法由以下步骤组成：</span></span><br><span class="line"><span class="number">1.</span>垃圾回收器构建<span class="string">&quot;roots&quot;</span>列表。Roots通常是代码中保留引用的全局变量。在JavaScript中，<span class="string">&quot;window&quot;</span>对象可以作为 root 全局变量示例。</span><br><span class="line"><span class="number">2.</span>所有的<span class="string">&quot;roots&quot;</span>被检查并标记为active（即不是垃圾）。所有的children也被递归检查。从<span class="string">&quot;root&quot;</span>能够到达的一切都不被认为是垃圾。</span><br><span class="line"><span class="number">3.</span>所有为不被标记为active的内存可以被认为是垃圾了。收集器限制可以释放这些内存并将其返回到操作系统。</span><br></pre></td></tr></table></figure>

<h4 id="106-浏览器包括4个进程："><a href="#106-浏览器包括4个进程：" class="headerlink" title="106.浏览器包括4个进程："></a>106.浏览器包括4个进程：</h4><p>1.主进程(Browser进程)，浏览器只有一个主进程，负责资源下载、界面展示等主要基础功能；<br>2.GPU进程，负责3D图示绘制<br>3.第三方插件进程，负责第三方插件处理<br>4.渲染进程(Render进程)，负责js执行，页面渲染等功能</p>
<p>请列出渲染进程中的主要包括的线程，并简单描述各个线程的功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>GUI渲染线程</span><br><span class="line"> - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</span><br><span class="line"> - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</span><br><span class="line"> - 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>JS引擎线程</span><br><span class="line"> - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</span><br><span class="line"> - JS引擎线程负责解析Javascript脚本，运行代码。</span><br><span class="line"> - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</span><br><span class="line"> - 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>事件触发线程</span><br><span class="line"> - 用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</span><br><span class="line"> - 当JS引擎执行代码块如setTimeOut时（也可是鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</span><br><span class="line"> - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</span><br><span class="line"> - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>定时触发器线程</span><br><span class="line"> - 浏览器定时计数器并不是由JavaScript引擎计数的（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</span><br><span class="line"> - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</span><br><span class="line"> - 注意，W3C在HTML标准中规定，规定要求<span class="built_in">setTimeout</span>中低于<span class="number">4</span>ms的时间间隔算为<span class="number">4</span>ms。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>异步http请求线程</span><br><span class="line"> - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</span><br><span class="line"> - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</span><br></pre></td></tr></table></figure>

<h4 id="107-javaScript中如何检测一个变量是一个String类型，请写出函数实现。"><a href="#107-javaScript中如何检测一个变量是一个String类型，请写出函数实现。" class="headerlink" title="107.javaScript中如何检测一个变量是一个String类型，请写出函数实现。"></a>107.javaScript中如何检测一个变量是一个String类型，请写出函数实现。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)使用<span class="keyword">typeof</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typeof</span>(obj)==<span class="string">&quot;string&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    alert(a(<span class="number">123</span>));<span class="comment">//false</span></span><br><span class="line">    alert(a(<span class="string">&quot;abc&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    <span class="keyword">typeof</span>()只能判断基本类型数据，对于引用类型只返回object</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)使用<span class="built_in">Object</span>原型的toString方法</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(data).slice(<span class="number">8</span>,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(type(<span class="number">123</span>));<span class="comment">//Number</span></span><br><span class="line">    alert(type(<span class="string">&quot;abc&quot;</span>));<span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">    该方法返回描述某个对象数据类型的字符串，如自定义的对象没有被覆盖，则会返回“[object type]”，其中，type则是实际的对象类型。。</span><br><span class="line">    这是因为toString为<span class="built_in">Object</span>的原型方法，而<span class="built_in">Array</span> 、<span class="built_in">Function</span>等类型作为<span class="built_in">Object</span>的实例，都重写了toString方法。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（<span class="built_in">Function</span>类型返回内容为函数体的字符串，<span class="built_in">Array</span>类型返回元素组成的字符串.....），而不会去调用<span class="built_in">Object</span>上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用<span class="built_in">Object</span>上原型toString方法。</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)使用构造器</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj.constructor === <span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    alert(b(<span class="number">123</span>));<span class="comment">//false</span></span><br><span class="line">    alert(b(<span class="string">&quot;abc&quot;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="108-this-和this关键字在jQuery中有何不同？"><a href="#108-this-和this关键字在jQuery中有何不同？" class="headerlink" title="108.$(this)和this关键字在jQuery中有何不同？"></a>108.$(this)和this关键字在jQuery中有何不同？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">this</span>表示javascript的dom对象，能够调用dom操作的API，比如innerHTML innerText setAttribute等</span><br><span class="line"><span class="number">2.</span>$(<span class="built_in">this</span>)表示把dom对象转换为jquery对象。你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。</span><br><span class="line"><span class="number">3.</span>jquery对象和dom对象可以相互转换</span><br><span class="line">   jquery对象转dom对象： <span class="keyword">var</span> $div = $(div);</span><br><span class="line">   dom对象转jquery对象： <span class="keyword">var</span> div = $(div)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h4 id="109-document-load和document-ready的区别"><a href="#109-document-load和document-ready的区别" class="headerlink" title="109.document.load和document.ready的区别"></a>109.document.load和document.ready的区别</h4><p>DOM文档解析：</p>
<ol>
<li>解析html结构</li>
<li>加载脚本和样式文件</li>
<li>解析并执行脚本</li>
<li>构造html的DOM模型      //ready</li>
<li>加载图片等外部资源文件</li>
<li>页面加载完毕               //load</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.document.ready：</span></span><br><span class="line">是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）；在DOM加载完成后就可以可以对DOM进行操作。</span><br><span class="line">一般情况一个页面响应加载的顺序是，解析html--&gt;加载js和css--&gt;解析并执行脚本--&gt;构造dom模型--&gt;加载图片等外部资源文件--&gt;页面加载完毕。那么Dom Ready应该在“构造dom模型”和“加载图片等外部资源文件”之间，就可以操作Dom了。</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.document.load：</span></span><br><span class="line">是onload，指示页面包含图片等文件在内的所有元素都加载完成。</span><br><span class="line">在<span class="built_in">document</span>文档加载完成后就可以可以对DOM进行操作，<span class="built_in">document</span>文档包括了加载图片等其他信息。</span><br><span class="line">那么Dom Load就是在页面响应加载的顺序中的“加载图片等其他信息”之后，就可以操作Dom了。</span><br></pre></td></tr></table></figure>

<p>总结：如果页面中要是没有图片之类的媒体文件的话ready与load是差不多的，但是页面中有文件就不一样了，所以还是推荐大家在工作中用ready。</p>
<h4 id="110-jQuery中-get-提交和-post-提交的区别"><a href="#110-jQuery中-get-提交和-post-提交的区别" class="headerlink" title="110.jQuery中$.get()提交和$.post()提交的区别"></a>110.jQuery中$.get()提交和$.post()提交的区别</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">相同点：都是异步请求的方式来获取服务端的数据；</span><br><span class="line">异同点：</span><br><span class="line"><span class="number">1</span>、请求方式不同：$.get() 方法使用GET方法来进行异步请求的。$.post() 方法使用POST方法来进行异步请求的。</span><br><span class="line"><span class="number">2</span>、参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。</span><br><span class="line"><span class="number">3</span>、数据传输大小不同：get方式传输的数据大小不能超过<span class="number">2</span>KB 而POST要大的多</span><br><span class="line"><span class="number">4</span>、安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。 </span><br></pre></td></tr></table></figure>

<h4 id="111-你为什么要用jQuery，你觉得jQuery有哪些好处"><a href="#111-你为什么要用jQuery，你觉得jQuery有哪些好处" class="headerlink" title="111.你为什么要用jQuery，你觉得jQuery有哪些好处"></a>111.你为什么要用jQuery，你觉得jQuery有哪些好处</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）写少代码,做多事情【write less <span class="keyword">do</span> more】</span><br><span class="line">（<span class="number">2</span>）免费，开源且轻量级的js库，容量很小.注意：项目中，提倡引用min版的js库</span><br><span class="line">（<span class="number">3</span>）兼容市面上主流浏览器，例如 IE，Firefox，Chrome</span><br><span class="line">（<span class="number">4</span>）强大的选择器，出色的DOM封装，可靠的事件处理机制，完善的Ajax，支持链式操作，隐式迭代</span><br><span class="line">（<span class="number">5</span>）文档手册很全，很详细</span><br><span class="line">（<span class="number">6</span>）成熟的插件可供选择</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery面试问题：</span></span><br><span class="line"><span class="comment">// https://blog.csdn.net/t0404/article/details/52048713</span></span><br></pre></td></tr></table></figure>

<h4 id="112-本地存储和离线缓存的区别-并说明各自用法"><a href="#112-本地存储和离线缓存的区别-并说明各自用法" class="headerlink" title="112.本地存储和离线缓存的区别,并说明各自用法?"></a>112.本地存储和离线缓存的区别,并说明各自用法?</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.本地存储和离线缓存区别：</span></span><br><span class="line">- 本地存储主要是将网站会话过程中的数据保存在客户端，突破了原来cookie存储大小的限制，相当于一个针对于前端页面的数据库。</span><br><span class="line">- 离线缓存主要作用是让用户在没有网络的情况下仍然可以访问缓存的网页，可以减少服务器的负载</span><br><span class="line">- 本地存储一般存储的都是数据，而离线缓存一般存储的是网页等</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.本地存储的用法</span></span><br><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);<span class="comment">//存储</span></span><br><span class="line"><span class="built_in">localStorage</span>.getItems(key);<span class="comment">//按key进行取值</span></span><br><span class="line"><span class="built_in">localStorage</span>.removeItems(key);<span class="comment">//按key单个删除</span></span><br><span class="line"><span class="built_in">localStorage</span>.clear();<span class="comment">//删除全部数据</span></span><br><span class="line"><span class="built_in">localStorage</span>.length;<span class="comment">//获得数据的数量</span></span><br><span class="line"><span class="built_in">localStorage</span>.valueOf();<span class="comment">//获取全部值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.离线缓存的用法</span></span><br><span class="line">    a. 在html标签添加manifest属性</span><br><span class="line">    在页面的html标签中添加manifest属性，属性值为manifest文件的路径。如：</span><br><span class="line"></span><br><span class="line">            &lt;!DOCTYPE HTML&gt; </span><br><span class="line">            &lt;html manifest=<span class="string">&quot;../js/demo.manifest&quot;</span>&gt;</span><br><span class="line">                    ...</span><br><span class="line">            &lt;/html&gt;</span><br><span class="line"></span><br><span class="line">    b. 编写manifest文件</span><br><span class="line">    manifest文件是简单的文本文件，它会告知浏览器需要缓存的内容以及不需要缓存的内容。</span><br><span class="line"></span><br><span class="line">    manifest文件可分为三部分： </span><br><span class="line">    (<span class="number">1</span>) CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 </span><br><span class="line">    (<span class="number">2</span>) NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 </span><br><span class="line">	(<span class="number">3</span>) FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 <span class="number">404</span> 页面）</span><br><span class="line"></span><br><span class="line">    简单示例:</span><br><span class="line">         CACHE MANIFEST</span><br><span class="line">            #version <span class="number">1.1</span>   <span class="comment">/*版本号*/</span></span><br><span class="line">            CACHE:</span><br><span class="line">                html/index.html <span class="comment">/*需要缓存的文件*/</span></span><br><span class="line">            NETWORK:</span><br><span class="line">                js/jquery.js <span class="comment">/*不需要缓存的文件*/</span></span><br><span class="line">            FALLBACK: </span><br><span class="line">                html/index.html <span class="comment">/*当页面无法访问时的回退页面*/</span></span><br></pre></td></tr></table></figure>

<h4 id="114-json的优缺点"><a href="#114-json的优缺点" class="headerlink" title="114.json的优缺点?"></a>114.json的优缺点?</h4><p>json的概念：json是一种轻量级的数据交换格式，具有良好的可读和便于快速编写的特性</p>
<p>json支持的数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">number：和JavaScript的&#96;number&#96;完全一致；</span><br><span class="line">boolean：就是JavaScript的&#96;true&#96;或&#96;false&#96;；</span><br><span class="line">string：就是JavaScript的&#96;string&#96;；</span><br><span class="line">null：就是JavaScript的&#96;null&#96;；</span><br><span class="line">array：就是JavaScript的&#96;Array&#96;表示方式——&#96;[]&#96;；</span><br><span class="line">object：就是JavaScript的&#96;&#123; ... &#125;&#96;表示方式。</span><br></pre></td></tr></table></figure>

<p>json的优缺点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 数据格式比较简单，易于读写，格式都是压缩的，占用宽带小</span><br><span class="line">- 支持多种语言，.JSON格式的编码比较简单</span><br><span class="line">- JSON的解码难度较低比起XML简单的多</span><br><span class="line">- JSON和js交互更加方便</span><br><span class="line">- JSON的速度远远快于XML</span><br></pre></td></tr></table></figure>

<h4 id="115-jquery有几种类型的选择器"><a href="#115-jquery有几种类型的选择器" class="headerlink" title="115.jquery有几种类型的选择器"></a>115.jquery有几种类型的选择器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">一、基本选择器(<span class="number">5</span>种)</span><br><span class="line"></span><br><span class="line">基本选择器是jQuery中最常用也是最简单的选择器，它通过元素的id、<span class="class"><span class="keyword">class</span>和标签名等来查找<span class="title">DOM</span>元素。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">1、<span class="title">ID</span>选择器 #<span class="title">id</span></span></span><br><span class="line"><span class="class">描述：根据给定的<span class="title">id</span>匹配一个元素， 返回单个元素（注：在网页中，<span class="title">id</span>名称不能重复）</span></span><br><span class="line">示例：$(&quot;#test&quot;) 选取 id 为 test 的元素</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、类选择器 .class</span><br><span class="line">描述：根据给定的类名匹配元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;.test&quot;</span>) 选取所有<span class="class"><span class="keyword">class</span>为<span class="title">test</span>的元素</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">3、元素(标签)选择器 <span class="title">element</span></span></span><br><span class="line"><span class="class">描述：根据给定的元素名匹配元素，返回元素集合</span></span><br><span class="line">示例：$(&quot;p&quot;) 选取所有的&lt;p&gt;元素 $(&quot;div&quot;) :选取所有的div标签</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、*</span><br><span class="line">描述：匹配所有元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;*&quot;</span>) 选取所有的元素</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、selector1，selector2,...,selectorN（并集选择器）</span><br><span class="line">描述：将每个选择器匹配到的元素合并后一起返回，返回合并后的元素集合</span><br><span class="line">示例：$(<span class="string">&quot;p,span,p.myClass&quot;</span>) 选取所有&lt;p&gt;,&lt;span&gt;和<span class="class"><span class="keyword">class</span>为<span class="title">myClass</span>的&lt;<span class="title">p</span>&gt;标签的元素集合</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">二、层次选择器(4种)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">层次选择器根据层次关系获取特定元素。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">1、后代选择器 </span></span><br><span class="line">示例：$(&quot;p span&quot;) 选取&lt;p&gt;元素里的所有的&lt;span&gt;元素（注：后代选择器选择父元素所有指定选择的元素，不管是儿子级，还是孙子级）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、子选择器 $(<span class="string">&quot;parent&gt;child&quot;</span>)</span><br><span class="line">示例：$(<span class="string">&quot;p&gt;span&quot;</span>) 选择&lt;p&gt;元素下的所有&lt;span&gt;元素 （注：子选择器只选择直属于父元素的子元素）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、兄弟选择器 $(<span class="string">&quot;prev+next&quot;</span>)</span><br><span class="line">描述：选取紧接在prev元素后的next元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;.one+p&quot;</span>) 选取<span class="class"><span class="keyword">class</span>为<span class="title">one</span>的下一个&lt;<span class="title">p</span>&gt;同辈元素集合</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">4、兄弟选择器 $(&quot;prev~siblings&quot;)</span><br><span class="line">描述：选取prev元素后的所有siblings元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;#two~p&quot;</span>)选取id为two的元素后所有&lt;p&gt;同辈元素集合</span><br><span class="line"></span><br><span class="line">三、过滤选择器(<span class="number">5</span>种)</span><br><span class="line"><span class="number">1</span>基本过滤选择器</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、 :first</span><br><span class="line">描述：选取第一个元素，返回单个元素</span><br><span class="line">示例：$(<span class="string">&quot;p:first&quot;</span>) 选取所有&lt;p&gt;元素中第一个&lt;p&gt;元素</span><br><span class="line"><span class="number">2</span>、 :last</span><br><span class="line">描述：选取最后一个元素，返回单个元素</span><br><span class="line">示例：$(<span class="string">&quot;p:last&quot;</span>) 选取所有&lt;p&gt;元素中最后一个&lt;p&gt;元素</span><br><span class="line"><span class="number">3</span>、 :not(selector)</span><br><span class="line">描述：去除所有与给定选择器匹配的元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;input:not(.myClass)&quot;</span>) 选取<span class="class"><span class="keyword">class</span>不是<span class="title">myClass</span>的&lt;<span class="title">input</span>&gt;元素</span></span><br><span class="line">4、 :even</span><br><span class="line">描述：选取索引是偶数的所有元素，索引从<span class="number">0</span>开始，返回元素集合</span><br><span class="line"><span class="number">5</span>、 :odd</span><br><span class="line">描述：选取索引是奇数的所有元素，索引从<span class="number">0</span>开始，返回元素集合</span><br><span class="line"><span class="number">6</span>、 :eq(index)</span><br><span class="line">描述：选取索引等于index的元素，索引从<span class="number">0</span>开始，返回单个元素</span><br><span class="line"><span class="number">7</span>、 :gt(index)</span><br><span class="line">描述：选取索引大于index的元素，索引从<span class="number">0</span>开始，返回元素集合</span><br><span class="line"><span class="number">8</span>、 :lt(index)</span><br><span class="line">描述：选取索引小于于index的元素，索引从<span class="number">0</span>开始，返回元素集合</span><br><span class="line"><span class="number">9</span>、 :focus</span><br><span class="line">描述：选取当前获取焦点的元素</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、内容过滤选择器</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、:contains(text)</span><br><span class="line">描述：选取含有文本内容为text的元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;p:contains(&#x27;我&#x27;)&quot;</span>) 选取含有文本“我”的元素</span><br><span class="line"><span class="number">2</span>、:empty</span><br><span class="line">描述：选取不包含子元素或者文本元素的空元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;p:empty&quot;</span>) 选取不包含子元素或者文本元素的空&lt;p&gt;元素（&lt;p&gt;&lt;/p&gt;）</span><br><span class="line"><span class="number">3</span>、:has(selector)</span><br><span class="line">描述：选取含有选择器所匹配的元素的元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;p:has(p)&quot;</span>) 选取含有&lt;p&gt;元素的&lt;p&gt;元素（&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">p</span>/&gt;</span></span>&lt;/p&gt;）</span><br><span class="line"><span class="number">4</span>、:parent</span><br><span class="line">描述：选取含有子元素或者文本的元素，返回元素集合</span><br><span class="line">示例：$(<span class="string">&quot;p:parent&quot;</span>) 选取含有子元素或者文本元素的&lt;p&gt;元素（&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">p</span>/&gt;</span></span>&lt;<span class="regexp">/p&gt;或者&lt;p&gt;文本&lt;/</span>p&gt;）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、可见性过滤选择器</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、:hidden</span><br><span class="line">描述：选取所有不可见的元素，返回元素集合</span><br><span class="line"><span class="number">2</span>、:visible</span><br><span class="line">描述：选取所有可见的元素，返回元素集合</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、属性过滤选择器（返回元素集合）</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、[attribute]</span><br><span class="line">示例：$(<span class="string">&quot;p[id]&quot;</span>) 选取拥有id属性的p元素</span><br><span class="line"><span class="number">2</span>、[attribute=value]</span><br><span class="line">示例：$(<span class="string">&quot;input[name=text]&quot;</span>) 选取拥有name属性等于text的input元素</span><br><span class="line"><span class="number">3</span>、[attribute!=value]</span><br><span class="line">示例：$(<span class="string">&quot;input[name!=text]&quot;</span>) 选取拥有name属性不等于text的input元素</span><br><span class="line"><span class="number">4</span>、[attribute^=value]</span><br><span class="line">示例：$(<span class="string">&quot;input[name^=text]&quot;</span>) 选取拥有name属性以text开始的input元素</span><br><span class="line"><span class="number">5</span>、[attribute$=value]</span><br><span class="line">示例：$(<span class="string">&quot;input[name$=text]&quot;</span>) 选取拥有name属性以text结束的input元素</span><br><span class="line"><span class="number">6</span>、[attribute=value]</span><br><span class="line">示例：$(<span class="string">&quot;input[name=text]&quot;</span>) 选取拥有name属性含有text的input元素</span><br><span class="line"><span class="number">7</span>、[attribute~=value]</span><br><span class="line">示例：$(<span class="string">&quot;input[class~=text]&quot;</span>) 选取拥有<span class="class"><span class="keyword">class</span>属性以空格分割的值中含有<span class="title">text</span>的<span class="title">input</span>元素</span></span><br><span class="line">8、attribute1[attributeN]</span><br><span class="line">描述：合并多个属性过滤选择器</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、表单对象属性过滤选择器（返回元素集合）</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、:enabled</span><br><span class="line">描述：选取所有可用元素</span><br><span class="line"><span class="number">2</span>、:disabled</span><br><span class="line">描述：选取所有不可用元素</span><br><span class="line"><span class="number">3</span>、:checked</span><br><span class="line">描述：选取所有被选中的元素（单选框，复选框）</span><br><span class="line">示例：$(<span class="string">&quot;input:checked&quot;</span>) 选取所有被选中的&lt;input&gt;元素</span><br><span class="line"><span class="number">4</span>、:selected</span><br><span class="line">描述：选取所有被选中的选项元素（下拉列表）</span><br><span class="line">示例：$(<span class="string">&quot;select option:selected&quot;</span>) 选取所有被选中的选项元素</span><br><span class="line"></span><br><span class="line">四、表单选择器（返回元素集合，使用相似）</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、:text</span><br><span class="line">描述：选择所有的单行文本框</span><br><span class="line">示例：$(<span class="string">&quot;:text&quot;</span>)选取所有的单行文本框</span><br><span class="line"><span class="number">2</span>、:password</span><br><span class="line">描述：选择所有的密码框</span><br><span class="line"><span class="number">3</span>、:button</span><br><span class="line">描述：选择所有的按钮</span><br><span class="line"><span class="number">4</span>、:checkbox</span><br><span class="line">描述：选择所有的多选框</span><br></pre></td></tr></table></figure>

<h4 id="116-将两个数合并，并删除第二个元素"><a href="#116-将两个数合并，并删除第二个元素" class="headerlink" title="116.将两个数合并，并删除第二个元素"></a>116.将两个数合并，并删除第二个元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组合并</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)js的<span class="built_in">Array</span>对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。</span><br><span class="line"><span class="keyword">var</span> array = array1.concat（array2）</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i <span class="keyword">in</span> array1</span>)</span>&#123;</span><br><span class="line">	array2.push(array1[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)利用ES6语法</span><br><span class="line"><span class="keyword">var</span> array = [...array1,...array2]</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组</span><br><span class="line">  调用a.push这个函数实例的apply方法，同时把，b当作参数传入，这样a.push这	个方法就会遍历b数组的所有元素，达到合并的效果。</span><br><span class="line"> array1.push.apply(array1,array2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除第二个元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)array.splice(<span class="number">1</span>,<span class="number">1</span>)    </span><br><span class="line"><span class="comment">//array.splice(1,1,5,6)表示在删除的位置添加元素5，6</span></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)<span class="keyword">delete</span> array[<span class="number">1</span>]</span><br><span class="line"><span class="comment">//只会删除了第二个元素，但是在其位置会显示empty，索引不会改变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="117-请写出一下数组相关方法的值"><a href="#117-请写出一下数组相关方法的值" class="headerlink" title="117.请写出一下数组相关方法的值"></a>117.请写出一下数组相关方法的值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>].filter(<span class="function"><span class="params">x</span>=&gt;</span><span class="literal">true</span>)          	 <span class="comment">//[&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>].every(<span class="function"><span class="params">x</span>=&gt;</span>x===<span class="string">&#x27;a&#x27;</span>)    		 <span class="comment">//false</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>].some(<span class="function"><span class="params">x</span>=&gt;</span>x===<span class="string">&#x27;a&#x27;</span>)    		 <span class="comment">//true</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>x+y)       		 <span class="comment">//3</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>].map(<span class="function"><span class="params">x</span>=&gt;</span>x+<span class="number">1</span>)             		 <span class="comment">//[2,3]</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,...[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]]			 		<span class="comment">//[&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">&quot;a&quot;</span>)        		 <span class="comment">//[&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>].findIndex(<span class="function"><span class="params">x</span>=&gt;</span>x===<span class="string">&#x27;c&#x27;</span>)   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="118-GET和POST的区别，何时使用POST？"><a href="#118-GET和POST的区别，何时使用POST？" class="headerlink" title="118.GET和POST的区别，何时使用POST？"></a>118.GET和POST的区别，何时使用POST？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</span><br><span class="line">2.POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</span><br><span class="line">3.GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，</span><br><span class="line">也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</span><br><span class="line">4.在以下情况中，请使用 POST 请求：</span><br><span class="line">	无法使用缓存文件（更新服务器上的文件或数据库）</span><br><span class="line">	向服务器发送大量数据（POST 没有数据量限制）</span><br><span class="line">	发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</span><br></pre></td></tr></table></figure>

<h4 id="119-说说-async-await-的串行和并行"><a href="#119-说说-async-await-的串行和并行" class="headerlink" title="119.说说 async / await 的串行和并行"></a>119.说说 async / await 的串行和并行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//async和await是es6中的新语法,它的诞生彻底解决了JS回调地狱的问题,在这个语法中,我们可以省去以往的promise语法中.then()的写法</span></span><br><span class="line"></span><br><span class="line">加<span class="keyword">async</span>修饰的方法有两个作用：</span><br><span class="line"><span class="number">1.</span>该方法中可以使用<span class="keyword">await</span></span><br><span class="line"><span class="number">2.</span>该方法需要返回一个promise</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span>可以出现在<span class="keyword">async</span>修饰的方法中，他的意思表示等待异步任务的执行完毕，<span class="keyword">await</span>后面需要跟一个promise</span><br><span class="line"></span><br><span class="line">比如下面的例子：</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result1 = <span class="keyword">await</span> axios(<span class="string">&quot;http://localhost:8888/aa&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> result2 = <span class="keyword">await</span> axios(<span class="string">&quot;http://localhost:8888/bb&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">request2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result3 = <span class="keyword">await</span> axios(<span class="string">&quot;http://localhost:8888/cc&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> result4 = <span class="keyword">await</span> axios(<span class="string">&quot;http://localhost:8888/dd&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">request1();</span><br><span class="line">request2();</span><br><span class="line"><span class="comment">//此时request1() 和 request2()这两个方法是并行执行的，request1的执行并不会堵塞当前线程</span></span><br><span class="line"><span class="comment">//而request1中的两个请求是串行执行的，也就是先必须拿到result1的结果后才能继续获取到result2的结果</span></span><br><span class="line"></span><br><span class="line">因此<span class="keyword">async</span>/<span class="keyword">await</span>的结合使用，可以将原来并行执行的异步任务改为串行执行，从而彻底解决js的回调低于的问题</span><br></pre></td></tr></table></figure>

<h4 id="120-数组求最大值-：var-arr-45-2-3-4-10-8-用es6求最大值"><a href="#120-数组求最大值-：var-arr-45-2-3-4-10-8-用es6求最大值" class="headerlink" title="120.数组求最大值 ：var arr=[45,2,3,4,10,8],用es6求最大值?"></a>120.数组求最大值 ：var arr=[45,2,3,4,10,8],用es6求最大值?</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">45</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> max = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a , b</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> b &gt; a ? b : a; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(max); </span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce:让数组中的前项和后项做某种计算，并累计最终值.</span></span><br></pre></td></tr></table></figure>

<h4 id="121-用代码实现下面数组以num的值的大小重新排列-并返回一个新的数组"><a href="#121-用代码实现下面数组以num的值的大小重新排列-并返回一个新的数组" class="headerlink" title="121.用代码实现下面数组以num的值的大小重新排列,并返回一个新的数组"></a>121.用代码实现下面数组以num的值的大小重新排列,并返回一个新的数组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    &#123;<span class="attr">num</span>:<span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">num</span>:<span class="number">100</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">num</span>:<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">num</span>:<span class="number">56</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>sort()方法  最简单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">100</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">num</span>: <span class="number">56</span> &#125;</span><br><span class="line">]  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">val1, val2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1.num - val2.num;</span><br><span class="line">&#125;;</span><br><span class="line">arr.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<h4 id="122-在jQuery的事件处理中return-false会有什么作用？"><a href="#122-在jQuery的事件处理中return-false会有什么作用？" class="headerlink" title="122.在jQuery的事件处理中return false会有什么作用？"></a>122.在jQuery的事件处理中return false会有什么作用？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阻止默认行为，取消事件冒泡，以及停止回调执行立即返回。</span><br><span class="line">比如，一个&#96;&lt;a&gt;&#96;点击后打开一个链接，如果你给这个&#96;&lt;a&gt;&#96;添加一个&#96;click&#96;事件，在&#96;click&#96;事件中&#96;return false&#96;，那么你点击这个&#96;&lt;a&gt;&#96;后，会处理&#96;click&#96;事件，但是不会打开链接了。</span><br></pre></td></tr></table></figure>

<h4 id="123-jQuery中如何获取元素不包括边框和padding的宽度和高度？"><a href="#123-jQuery中如何获取元素不包括边框和padding的宽度和高度？" class="headerlink" title="123.jQuery中如何获取元素不包括边框和padding的宽度和高度？"></a>123.jQuery中如何获取元素不包括边框和padding的宽度和高度？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a.width()     获取内容的宽度</span><br><span class="line">$a.height()</span><br><span class="line"></span><br><span class="line">$a.innerWidth()   获取边框以内的宽度</span><br><span class="line"></span><br><span class="line">$a.outerWidth()     获取边框以及边框以内的宽度</span><br><span class="line">$a.outerWidth(true)  获取margin+border+padding+content总宽度</span><br></pre></td></tr></table></figure>

<h4 id="124-jQuery中on和one函数的作用是什么？分别有哪几个参数？"><a href="#124-jQuery中on和one函数的作用是什么？分别有哪几个参数？" class="headerlink" title="124.jQuery中on和one函数的作用是什么？分别有哪几个参数？"></a>124.jQuery中on和one函数的作用是什么？分别有哪几个参数？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">on可以在匹配元素上绑定一个或者多个事件处理函数，使用off()方法可以删除on()方法绑定的事件。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">events   一个或多个用空格分隔的事件类型和可选的命名空间。</span><br><span class="line">selector   可选。一个选择器字符串，用以过滤选定的元素，该选择器的后裔元素将调用处理程序。如果选择是空或被忽略，当它到达选定的元素，事件总是触发。</span><br><span class="line">data    可选。作为event.data属性值传递给事件对象的额外数据对象以供事件处理函数处理。</span><br><span class="line">fn   该事件被触发时执行的函数。 false值也可以做一个函数的简写，返回false。</span><br><span class="line"></span><br><span class="line">$(&#39;#uu&#39;).on(&#39;click&#39;,function()&#123;&#125;)   直接给uu添加点击事件</span><br><span class="line">$(&#39;#uu&#39;).on(&#39;click&#39;,&#39;li&#39;,function()&#123;&#125;)   li的click事件委托给uu来处理</span><br><span class="line">$(&#39;#uu&#39;).off(&#39;click&#39;,&#39;li&#39;)   解绑事件</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one() 方法为被选元素附加一个或多个事件处理程序，并规定当事件发生时运行的函数。</span><br><span class="line">当使用 one() 方法时，每个元素只能运行一次事件处理器函数。 </span><br><span class="line">$(selector).one(event,data,function)</span><br><span class="line">event    必需，规定添加到元素的一个或多个事件，由空格分隔多个事件，必须是有效的事件。</span><br><span class="line">data     可选。规定传递到函数的额外数据。</span><br><span class="line">function 必需。规定当事件发生时运行的函数。</span><br></pre></td></tr></table></figure>

<h4 id="125-现有一个数组a-长度未知-数组每一项的数据类型约定为Number-请用Javescript-实现以下逻辑："><a href="#125-现有一个数组a-长度未知-数组每一项的数据类型约定为Number-请用Javescript-实现以下逻辑：" class="headerlink" title="125.现有一个数组a,长度未知,数组每一项的数据类型约定为Number,请用Javescript 实现以下逻辑："></a>125.现有一个数组a,长度未知,数组每一项的数据类型约定为Number,请用Javescript 实现以下逻辑：</h4><p>如果a的长度为零,则为其添加一个新项,值为1。</p>
<p>如果a的长度不为零,则按照先进先出的原则,移除一项。(代码越少评价越高)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：a.length === <span class="number">0</span> ? a.push(<span class="number">1</span>) : a.shift();</span><br></pre></td></tr></table></figure>

<h4 id="126-10-‘20’-？"><a href="#126-10-‘20’-？" class="headerlink" title="126.10+‘20’=？"></a>126.10+‘20’=？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答：<span class="number">1020</span> <span class="comment">// string</span></span><br><span class="line">数值字符串和其他数值运算时先将字符串转换成数值在运算，字符串和其他任何东西相加都得到字符串</span><br></pre></td></tr></table></figure>

<h4 id="127-用XML和JSON两种格式描述下面表格的数据"><a href="#127-用XML和JSON两种格式描述下面表格的数据" class="headerlink" title="127.用XML和JSON两种格式描述下面表格的数据"></a>127.用XML和JSON两种格式描述下面表格的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XML:</span><br><span class="line">&lt;student&gt;</span><br><span class="line">	&lt;id&gt;1001&lt;&#x2F;id&gt;</span><br><span class="line">	&lt;name&gt;张三&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;gender&gt;男&lt;&#x2F;gender&gt;</span><br><span class="line">	&lt;age&gt;20&lt;&#x2F;age&gt;</span><br><span class="line">&lt;&#x2F;student&gt;</span><br><span class="line">&lt;student&gt;</span><br><span class="line">	&lt;id&gt;1002&lt;&#x2F;id&gt;</span><br><span class="line">	&lt;name&gt;李四&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;gender&gt;女&lt;&#x2F;gender&gt;</span><br><span class="line">	&lt;age&gt;22&lt;&#x2F;age&gt;</span><br><span class="line">&lt;&#x2F;student&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>:</span><br><span class="line"><span class="string">&quot;data&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="string">&quot;id&quot;</span>:<span class="string">&quot;1001&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:<span class="string">&quot;20&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="string">&quot;id&quot;</span>:<span class="string">&quot;1002&quot;</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">        <span class="string">&quot;gender&quot;</span>:<span class="string">&quot;女&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:<span class="string">&quot;22&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="128-使用-typeof-bar-“object”-来确定-bar-是否是对象的潜在陷阱是什么？如何避免这个陷阱？"><a href="#128-使用-typeof-bar-“object”-来确定-bar-是否是对象的潜在陷阱是什么？如何避免这个陷阱？" class="headerlink" title="128.使用 typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？"></a>128.<strong>使用</strong> <strong>typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？</strong>如何避免这个陷阱？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尽管 <span class="keyword">typeof</span> bar === <span class="string">&quot;object&quot;</span> 是检查 bar 是否对象的可靠方法，令人惊讶的是在JavaScript中 <span class="literal">null</span> 也被认为是对象！ 因此，令大多数开发人员惊讶的是，下面的代码将输出 <span class="literal">true</span> (而不是<span class="literal">false</span>) 到控制台：</span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bar === <span class="string">&quot;object&quot;</span>);  <span class="comment">// logs true!</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只要清楚这一点，同时检查 bar 是否为 <span class="literal">null</span>，就可以很容易地避免问题：</span><br><span class="line"><span class="built_in">console</span>.log((bar !== <span class="literal">null</span>) &amp;&amp; (<span class="keyword">typeof</span> bar === <span class="string">&quot;object&quot;</span>));  <span class="comment">// logs false</span></span><br></pre></td></tr></table></figure>

<h4 id="129-封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？"><a href="#129-封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？" class="headerlink" title="129.封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？"></a>129.封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？</h4><p>这是一个越来越普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）采用。这种技术创建了一个围绕文件全部内容的闭包，<strong>（流行，普遍）</strong></p>
<p>也许是最重要的是，创建了一个私有的命名空间，从而有助于避免不同JavaScript模块和库之间潜在的名称冲突。<strong>（命名污染）</strong></p>
<p>这种技术的另一个特点是，允许一个易于引用的（假设更短的）别名用于全局变量。这通常用于，例如，jQuery插件中。jQuery允许你使用<code>jQuery.noConflict()</code>，来禁用 <code>$</code> 引用到jQuery命名空间。在完成这项工作之后，你的代码仍然可以使用<code>$</code> 利用这种闭包技术，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123; <span class="comment">/* jQuery plugin code referencing $ */</span> &#125; )(jQuery);</span><br></pre></td></tr></table></figure>

<h4 id="130-不借助临时变量，实现两个变量的值的交换"><a href="#130-不借助临时变量，实现两个变量的值的交换" class="headerlink" title="130.不借助临时变量，实现两个变量的值的交换"></a>130.不借助临时变量，实现两个变量的值的交换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.方法1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">445</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">33</span>;</span><br><span class="line">b = a - b; </span><br><span class="line">a = a - b; </span><br><span class="line">b = a + b; </span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br><span class="line"><span class="number">33</span>,<span class="number">445</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.方法2</span></span><br><span class="line"><span class="keyword">let</span> [b,a] = [a,b]</span><br></pre></td></tr></table></figure>

<h4 id="131-ajax同步请求和异步请求的区别？"><a href="#131-ajax同步请求和异步请求的区别？" class="headerlink" title="131.ajax同步请求和异步请求的区别？"></a>131.ajax同步请求和异步请求的区别？</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。</span><br><span class="line">用户填写所有信息后，提交给服务器，等待服务器的回应（检验数据），是一次性的。信息错误又要重新填写！</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。当用户填写完一条信息后，该信息会自动向服务器提交，然后服务器响应客户端，在此过程中，用户依然在填写表格的信息，即向服务器请求多次，节省了用户的时间，提高了用户的体验。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>当XMLHttpRequest的open方法第三个参数是<span class="literal">true</span>则是异步请求，反之则是同步请求</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/bar/foo.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="132-请说明setTimeout与setInterval的区别？"><a href="#132-请说明setTimeout与setInterval的区别？" class="headerlink" title="132.请说明setTimeout与setInterval的区别？"></a>132.请说明setTimeout与setInterval的区别？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>()方法只运行一次，也就是说当达到设定的时间后就出发运行指定的代码，运行完后就结束了，如果还想再次执行同样的函数，可以在函数体内再次调用<span class="built_in">setTimeout</span>()，可以达到循环调用的效果。</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>()是循环执行的，即每达到指定的时间间隔就执行相应的函数或者表达式，是真正的定时器。</span><br></pre></td></tr></table></figure>

<h4 id="133-如何避免JS全局变量的污染问题？"><a href="#133-如何避免JS全局变量的污染问题？" class="headerlink" title="133.如何避免JS全局变量的污染问题？"></a>133.如何避免JS全局变量的污染问题？</h4><p>1.定义全局变量命名空间<br>只创建一个全局变量，并定义该变量为当前应用容器，把其他全局变量追加在该命名空间下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my=&#123;&#125;;</span><br><span class="line">my.name=&#123;</span><br><span class="line">    big_name:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">    small_name:<span class="string">&quot;lisi&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">my.work=&#123;</span><br><span class="line">    school_work:<span class="string">&quot;study&quot;</span>,</span><br><span class="line">    family_work:<span class="string">&quot;we are&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2 . 利用匿名函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> exp=&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> name=<span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    exp.method=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">window</span>.ex=exp;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用模块化</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>CommonJS</span><br><span class="line"><span class="number">2.</span>AMD(RequireJS):用define()定义模块，用<span class="built_in">require</span>()加载模块。</span><br><span class="line"><span class="number">3.</span>CMD(sea.js):用define()定义模块，用<span class="built_in">require</span>()加载模块</span><br><span class="line"><span class="number">4.</span>ES6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="134-如何从函数外部访问函数内部的局部变量？"><a href="#134-如何从函数外部访问函数内部的局部变量？" class="headerlink" title="134.如何从函数外部访问函数内部的局部变量？"></a>134.如何从函数外部访问函数内部的局部变量？</h4><p>使用闭包的方法，在函数的内部，再定义一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　n=<span class="number">999</span>;</span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把局部变量挂载到window</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="built_in">window</span>.a = a;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="135-请描述出Math对象的常用方法，以及Array，String方法和属性"><a href="#135-请描述出Math对象的常用方法，以及Array，String方法和属性" class="headerlink" title="135.请描述出Math对象的常用方法，以及Array，String方法和属性"></a><strong>135.请描述出Math对象的常用方法，以及Array，String方法和属性</strong></h4><p>Math常用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">console.log(Math.PI); &#x2F;&#x2F;圆周率3.141592653589793</span><br><span class="line">Math.random();&#x2F;&#x2F;介于 0 和 1 之间的伪随机数。</span><br><span class="line">Math.ceil(6.6);&#x2F;&#x2F;获取大于或等于提供数值的最小整数--向上取整</span><br><span class="line">Math.floor(8.8);&#x2F;&#x2F;获取小于或等于提供数值的最大整数--向下取整</span><br><span class="line">Math.round(9.9);&#x2F;&#x2F;四舍五入</span><br><span class="line">Math.max(10,20,15);&#x2F;&#x2F;取多个值中的最大值</span><br><span class="line">Math.min(10,20,15);&#x2F;&#x2F;取多个值中的最小值</span><br><span class="line">Math.pow(10,2);&#x2F;&#x2F;返回x的y次幂</span><br><span class="line">Math.sqrt(100);&#x2F;&#x2F;求平方根</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Array：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">属性： <span class="title">constructor</span>  返回对创建此对象的数组函数的引用。</span><br><span class="line">			<span class="title">length</span>  		设置或返回数组中元素的数目。</span><br><span class="line">			<span class="title">prototyp</span>		可以向对象添加属性和方法。</span><br><span class="line"></span><br><span class="line">方法： <span class="title">concat</span>(<span class="params"></span>)        连接两个或更多的数组，并返回结果。</span><br><span class="line">			<span class="title">join</span>(<span class="params"></span>)			把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</span><br><span class="line">			<span class="title">pop</span>(<span class="params"></span>)            删除并返回数组的最后一个元素</span><br><span class="line">			<span class="title">push</span>(<span class="params"></span>)			向数组的末尾添加一个或更多元素，并返回新的长度。</span><br><span class="line">			<span class="title">reverse</span>(<span class="params"></span>)       颠倒数组中元素的顺序。</span><br><span class="line">			<span class="title">shift</span>(<span class="params"></span>)			删除并返回数组的第一个元素</span><br><span class="line">			<span class="title">slice</span>(<span class="params"></span>)             从某个已有的数组返回选定的元素</span><br><span class="line">			<span class="title">sort</span>(<span class="params"></span>)              对数组的元素进行排序</span><br><span class="line">			<span class="title">splice</span>(<span class="params"></span>)          删除元素，并向数组添加新元素。</span><br><span class="line">			<span class="title">toString</span>(<span class="params"></span>)  	把数组转换为字符串，并返回结果。</span><br><span class="line">			<span class="title">unshift</span>(<span class="params"></span>)        向数组的开头添加一个或更多元素，并返回新的长度。</span><br><span class="line">			<span class="title">valueOf</span>(<span class="params"></span>)		返回数组对象的原始值</span><br><span class="line">             <span class="title">some</span>(<span class="params"></span>)           数组中任何一个元素是否满足指定要求就会返回<span class="title">true</span>，所有元素不满足指定条件就返回<span class="title">false</span>   </span><br><span class="line">             <span class="title">every</span>(<span class="params"></span>)          数组中所有元素都满足指定条件才会返回<span class="title">true</span></span><br><span class="line">             <span class="title">filter</span>(<span class="params"></span>)         过滤数据，返回新的数据</span><br><span class="line">             <span class="title">map</span>(<span class="params"></span>)            遍历数组，返回新的 数据</span><br><span class="line">             <span class="title">forEach</span>(<span class="params"></span>)        遍历数组</span><br><span class="line">             <span class="title">findIndex</span>(<span class="params"></span>)      根据条件查询下标</span><br><span class="line">             <span class="title">reduce</span>(<span class="params"></span>)         累计运算</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>String:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">属性：<span class="title">constructor</span>  返回对创建此对象的数组函数的引用。</span><br><span class="line">			<span class="title">length</span>  		设置或返回数组中元素的数目。</span><br><span class="line">			<span class="title">prototyp</span>		可以向对象添加属性和方法。</span><br><span class="line"></span><br><span class="line">方法：<span class="title">charAt</span>(<span class="params"></span>)       返回在指定位置的字符。</span><br><span class="line">			<span class="title">concat</span>(<span class="params"></span>)  	连接字符串。</span><br><span class="line">			<span class="title">indexOf</span>(<span class="params"></span>)   检索字符串。</span><br><span class="line">			<span class="title">match</span>(<span class="params"></span>)	找到一个或多个正则表达式的匹配。</span><br><span class="line">			<span class="title">replace</span>(<span class="params"></span>)	替换与正则表达式匹配的子串。</span><br><span class="line">			<span class="title">slice</span>(<span class="params"></span>)			提取字符串的片断，并在新的字符串中返回被提取的部分。</span><br><span class="line">			<span class="title">split</span>(<span class="params"></span>)			把字符串分割为字符串数组</span><br><span class="line">			<span class="title">sub</span>(<span class="params"></span>)			把字符串显示为下标。</span><br><span class="line">			<span class="title">sup</span>(<span class="params"></span>)				把字符串显示为上标。</span><br><span class="line">			<span class="title">toLowerCase</span>(<span class="params"></span>)	把字符串转换为小写。</span><br><span class="line">			<span class="title">toUpperCase</span>(<span class="params"></span>)  把字符串转换为大写。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="136-ES6箭头函数和ES5普通函数一样吗？"><a href="#136-ES6箭头函数和ES5普通函数一样吗？" class="headerlink" title="136.ES6箭头函数和ES5普通函数一样吗？"></a><strong>136.<code>ES6</code>箭头函数和<code>ES5</code>普通函数一样吗？</strong></h4><p>箭头函数与传统函数的不同点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.没有this,super,arguments和new.target绑定，箭头函数中的这些值由外围最近一层非箭头函数决定。</span><br><span class="line">2.不能通过new关键字调用。它没有[[Construct]],所以不能用作构造函数。如用会报错</span><br><span class="line">3.没有原型（prototype）</span><br><span class="line">4.不可以改变this的绑定，函数内部的this值不可被改变，在函数的生命周期内始终保持一致。</span><br><span class="line">5.不支持arguments对象。所以只能通过命名参数和不定参数两种形式访问函数参数。</span><br><span class="line">6.不支持重复命名的函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="137-以下代码输出的结果是-。"><a href="#137-以下代码输出的结果是-。" class="headerlink" title="137.以下代码输出的结果是___。"></a>137.以下代码输出的结果是___。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;George&quot;</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&quot;John&quot;</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&quot;Thomas&quot;</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&quot;James&quot;</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&quot;Adrew&quot;</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&quot;Martin&quot;</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;William&quot;</span>)  <span class="comment">//从数组第2个位置开始把后面3个元素替换成William</span></span><br><span class="line"><span class="built_in">document</span>.write(arr) <span class="comment">// George,John,William,Martin</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
